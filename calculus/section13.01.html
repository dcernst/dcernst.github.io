<!DOCTYPE HTML>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
<meta http-equiv="Content-Language" Content="en">
<title>13.1 Space Curves</title>
<!--
<script type="text/javascript" src="js/deployJava.js"></script>
<link rel="stylesheet" type="text/css" href="http://jsxgraph.uni-bayreuth.de/distrib/jsxgraph.css" />
-->
<!-- use Jsxgraph to create figures: http://jsxgraph.uni-bayreuth.de/wp/ -->
<link rel="stylesheet" type="text/css" href="css/jsxgraph.css" />
<script type="text/javascript" src="js/jsxgraphcore.js"></script>
<script src="js/three.min.js"></script>
<script src="js/Detector.js"></script>
<script src="js/TrackballControls.js"></script>
<script src="js/OrthographicTrackballControls.js"></script>
<script src="js/THREEx.KeyboardState.js"></script>
<script src="js/THREEx.FullScreen.js"></script>
<script src="js/THREEx.WindowResize.js"></script>
<script type='text/javascript' src='js/DAT.GUI.min.js'></script>
<script>
window.requestAnimFrame = (function(){
    return  window.requestAnimationFrame       || 
        window.webkitRequestAnimationFrame || 
        window.mozRequestAnimationFrame    || 
        window.oRequestAnimationFrame      || 
        window.msRequestAnimationFrame     || 
        function(/* function */ callback, /* DOMElement */
            element){
            window.setTimeout(callback, 1000 / 60);
        };
})();
</script>
<script src="js/ifvisible.min.js"></script>
<script src="js/conrec.js"></script>
<script>
active = true;
ifvisible.setIdleDuration(10);
ifvisible.on("idle", function(){
    active = false;
//    console.log("idle");
});

ifvisible.on("wakeup", function(){
    active = true;
//    console.log("wakeup");
});
</script>
<script src="js/parser.js"></script>
<link href="css/whitman.css" rel="stylesheet" type="text/css" /><link href="css/calculus.css" rel="stylesheet" type="text/css" /><link href="css/knowlstyle.css" rel="stylesheet" type="text/css" />

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js","TeX/AMSmath.js","TeX/AMSsymbols.js"],
  jax: ["input/TeX","output/HTML-CSS"],
  tex2jax: {
    inlineMath: [['$','$'],["\\(","\\)"]],
    processEscapes: true,
  },
TeX: {
   Macros: {
    val: "\\mathop{\\rm val}",
    divides: "\\mid",
    ndivides: "\\mathrel{\\not|}",
    fix: "\\mathop{\\rm fix}",
    id: "\\mathop{\\rm id}",
    na: "\\mathop{\\rm na}",
    d: "\\mathop{\\rm\\strut d}\\nolimits ",
    legendre: ["\\left(\\frac{#1}{#2}\\right)",2],
    normalbaselines: "",
    notdiv: "\\nmid",
    implies: "\\Rightarrow",
    iff: "\\Leftrightarrow",
    sevenpoint: "\\scriptsize",
    ds: "\\displaystyle",
    lcm: "\\operatorname{lcm}",
    arccot: "\\operatorname{arccot}",
    arcsec: "\\operatorname{arcsec}",
    arccsc: "\\operatorname{arccsc}",
    arccosh: "\\operatorname{arccosh}",
    arcsinh: "\\operatorname{arcsinh}",
    arcsech: "\\operatorname{arcsech}",
    sech: "\\operatorname{sech}",
    csch: "\\operatorname{csch}",
    R: "{\\mathbb R}",
    sb: "_",
    sp: "^",
    Q: "{\\mathbb Q}",
    C: "{\\mathbb C}",
    N: "{\\mathbb N}",
    Z: "{\\mathbb Z}",
    U: "{\\mathbb U}",
    v: ["\\langle #1\\rangle",1],
    dint: ["{\\mathchoice{\\mathop{\\int\\!\\!\\!\\int}_{#1}}{\\mathop{\\int\\!\\!\\!\\int}_{#1}}{\\mathop{\\int\\!\\!\\!\\int}}{\\mathop{\\int\\!\\!\\!\\int}}}",1],
    tint: ["{\\mathchoice{\\mathop{\\int\\!\\!\\!\\int\\!\\!\\!\\int}_{#1\\;}}{\\mathop{\\int\\!\\!\\!\\int\\!\\!\\!\\int}_{#1}}{\\mathop{\\int\\!\\!\\!\\int\\!\\!\\!\\int}_{#1}}{\\mathop{\\int\\!\\!\\!\\int\\!\\!\\!\\int}_{#1}}}",1]
   }
},
  "HTML-CSS": { scale: 100},
  menuSettings: { zscale: "150%", zoom: "Double-Click" }
});
    JXG.Options.text.display = 'html';
    JXG.Options.text.useMathJax = true;
</script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/math
jax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<script>
MathJax.Hub.Register.StartupHook("End",function () {
  if(typeof window.orientation === 'undefined'){
    var i,x;
    x = document.getElementsByClassName("webgl_display");
    for (i=0; i<x.length; i++) {
      x[i].style.display = "block";
    }
    x = document.getElementsByClassName("no_webgl_display");
    for (i=0; i<x.length; i++) {
      x[i].style.display = "none";
    }
  }
});
</script>

<script src="js/jquery-3.1.0.min.js"></script>
<script src="https://sagecell.sagemath.org/static/embedded_sagecell.js"></script>
<script src="js/jquery.visible.min.js"></script>
<script type="text/javascript" src="js/knowl.js"></script>
<style type="text/css">

.sagecell .CodeMirror {
  height: auto;
}

.sagecell .CodeMirror-scroll {
  overflow-y: hidden;
  overflow-x: auto;
}

.sagecell-practice .CodeMirror-scroll {
}

.sagecell button.sagecell_evalButton {
    font-size: 50%;
}

.sagecell_sessionContainer {
    margin-bottom:1em;
}
</style>
<script>
function toggle(a) {
  var b = String(a);
  b=b.replace("contents","button");
  if (document.getElementById(a).style.display == "block") {
    document.getElementById(a).style.display = "none";
    document.getElementById(b).src = "expand_submenu.png";
  } else {
    document.getElementById(a).style.display = "block";
    document.getElementById(b).src = "collapse_submenu.png";
  }
}
function toggle_sidebar() {
  if (document.getElementById('sidebar').style.display == "block") {
    document.getElementById('sidebar').style.display = "none";
    document.getElementById('menu_expand').style.display = "block";
  } else {
    document.getElementById('sidebar').style.display = "block";
    document.getElementById('menu_expand').style.display = "none";
  }
}
</script>

</head>

<body class="" onload="toggle('chapter_13_contents')">
<div id="header">
<div class="right">
<div class="bread">
  <a href=".">Home</a> &raquo; <a href="chapter13.html">Vector Functions</a> &raquo; <a href="section13.01.html">Space Curves</a>
</div>

<FORM method=GET action=https://www.google.com/custom id="search">
<INPUT TYPE=text name=q size=31 maxlength=255 value="" style="font-size:small">
<INPUT type=submit name=sa VALUE="Search the book" style="font-size:small">
<INPUT type=hidden name=cof VALUE="AH:center;AWFID:198dc2b883340b1f;">
<input type=hidden name=domains value="www.whitman.edu">
<input type=hidden name=sitesearch value="www.whitman.edu/mathematics/calculus_online/">
</FORM>
<div id="title"><span id="title-content">13.1 Space Curves</span></div><a href="#exercises">[Jump to exercises]</a>
</div>
</div>
<div id="menu_expand" style="display:none"><a href="javascript:toggle_sidebar()">Expand menu</a></div>
<div id="sidebar" style="display:block">
<h2 id="menu_collapse"><a href='javascript:toggle_sidebar()'>Collapse menu</a></h2>
<h2 class="link"><img id="chapter_01_button" src="expand_submenu.png" onclick='toggle("chapter_01_contents")'><a href="chapter01.html">1 Analytic Geometry</a></h2>

<ul class="list" id="chapter_01_contents">
<li><a href="section01.01.html">1. Lines</a></li>
<li><a href="section01.02.html">2. Distance Between Two Points; Circles</a></li>
<li><a href="section01.03.html">3. Functions</a></li>
<li><a href="section01.04.html">4. Shifts and Dilations</a></li>
</ul>

<h2 class="link"><img id="chapter_02_button" src="expand_submenu.png" onclick='toggle("chapter_02_contents")'><a href="chapter02.html">2 Instantaneous Rate of Change:  The Derivative</a></h2>

<ul class="list" id="chapter_02_contents">
<li><a href="section02.01.html">1. The slope of a function</a></li>
<li><a href="section02.02.html">2. An example</a></li>
<li><a href="section02.03.html">3. Limits</a></li>
<li><a href="section02.04.html">4. The Derivative Function</a></li>
<li><a href="section02.05.html">5. Adjectives For Functions</a></li>
</ul>

<h2 class="link"><img id="chapter_03_button" src="expand_submenu.png" onclick='toggle("chapter_03_contents")'><a href="chapter03.html">3 Rules for Finding Derivatives</a></h2>

<ul class="list" id="chapter_03_contents">
<li><a href="section03.01.html">1. The Power Rule</a></li>
<li><a href="section03.02.html">2. Linearity of the Derivative</a></li>
<li><a href="section03.03.html">3. The Product Rule</a></li>
<li><a href="section03.04.html">4. The Quotient Rule</a></li>
<li><a href="section03.05.html">5. The Chain Rule</a></li>
</ul>

<h2 class="link"><img id="chapter_04_button" src="expand_submenu.png" onclick='toggle("chapter_04_contents")'><a href="chapter04.html">4 Transcendental Functions</a></h2>

<ul class="list" id="chapter_04_contents">
<li><a href="section04.01.html">1. Trigonometric Functions</a></li>
<li><a href="section04.02.html">2. The Derivative of $\sin x$</a></li>
<li><a href="section04.03.html">3. A hard limit</a></li>
<li><a href="section04.04.html">4. The Derivative of $\sin x$, continued</a></li>
<li><a href="section04.05.html">5. Derivatives of the Trigonometric Functions</a></li>
<li><a href="section04.06.html">6. Exponential and Logarithmic functions</a></li>
<li><a href="section04.07.html">7. Derivatives of the exponential and  logarithmic functions</a></li>
<li><a href="section04.08.html">8. Implicit Differentiation</a></li>
<li><a href="section04.09.html">9. Inverse Trigonometric Functions</a></li>
<li><a href="section04.10.html">10. Limits revisited</a></li>
<li><a href="section04.11.html">11. Hyperbolic Functions</a></li>
</ul>

<h2 class="link"><img id="chapter_05_button" src="expand_submenu.png" onclick='toggle("chapter_05_contents")'><a href="chapter05.html">5 Curve Sketching</a></h2>

<ul class="list" id="chapter_05_contents">
<li><a href="section05.01.html">1. Maxima and Minima</a></li>
<li><a href="section05.02.html">2. The first derivative test</a></li>
<li><a href="section05.03.html">3. The second derivative test</a></li>
<li><a href="section05.04.html">4. Concavity and inflection points</a></li>
<li><a href="section05.05.html">5. Asymptotes and Other Things to Look For</a></li>
</ul>

<h2 class="link"><img id="chapter_06_button" src="expand_submenu.png" onclick='toggle("chapter_06_contents")'><a href="chapter06.html">6 Applications of the Derivative</a></h2>

<ul class="list" id="chapter_06_contents">
<li><a href="section06.01.html">1. Optimization</a></li>
<li><a href="section06.02.html">2. Related Rates</a></li>
<li><a href="section06.03.html">3. Newton's Method</a></li>
<li><a href="section06.04.html">4. Linear Approximations</a></li>
<li><a href="section06.05.html">5. The Mean Value Theorem</a></li>
</ul>

<h2 class="link"><img id="chapter_07_button" src="expand_submenu.png" onclick='toggle("chapter_07_contents")'><a href="chapter07.html">7 Integration</a></h2>

<ul class="list" id="chapter_07_contents">
<li><a href="section07.01.html">1. Two examples</a></li>
<li><a href="section07.02.html">2. The Fundamental Theorem of Calculus</a></li>
<li><a href="section07.03.html">3. Some Properties of Integrals</a></li>
</ul>

<h2 class="link"><img id="chapter_08_button" src="expand_submenu.png" onclick='toggle("chapter_08_contents")'><a href="chapter08.html">8 Techniques of Integration</a></h2>

<ul class="list" id="chapter_08_contents">
<li><a href="section08.01.html">1. Substitution</a></li>
<li><a href="section08.02.html">2. Powers of sine and cosine</a></li>
<li><a href="section08.03.html">3. Trigonometric Substitutions</a></li>
<li><a href="section08.04.html">4. Integration by Parts</a></li>
<li><a href="section08.05.html">5. Rational Functions</a></li>
<li><a href="section08.06.html">6. Numerical Integration</a></li>
<li><a href="section08.07.html">7. Additional exercises</a></li>
</ul>

<h2 class="link"><img id="chapter_09_button" src="expand_submenu.png" onclick='toggle("chapter_09_contents")'><a href="chapter09.html">9 Applications of Integration</a></h2>

<ul class="list" id="chapter_09_contents">
<li><a href="section09.01.html">1. Area between curves</a></li>
<li><a href="section09.02.html">2. Distance, Velocity, Acceleration</a></li>
<li><a href="section09.03.html">3. Volume</a></li>
<li><a href="section09.04.html">4. Average value of a function</a></li>
<li><a href="section09.05.html">5. Work</a></li>
<li><a href="section09.06.html">6. Center of Mass</a></li>
<li><a href="section09.07.html">7. Kinetic energy; improper integrals</a></li>
<li><a href="section09.08.html">8. Probability</a></li>
<li><a href="section09.09.html">9. Arc Length</a></li>
<li><a href="section09.10.html">10. Surface Area</a></li>
</ul>

<h2 class="link"><img id="chapter_10_button" src="expand_submenu.png" onclick='toggle("chapter_10_contents")'><a href="chapter10.html">10 Polar Coordinates,  Parametric Equations</a></h2>

<ul class="list" id="chapter_10_contents">
<li><a href="section10.01.html">1. Polar Coordinates</a></li>
<li><a href="section10.02.html">2. Slopes in polar coordinates</a></li>
<li><a href="section10.03.html">3. Areas in polar coordinates</a></li>
<li><a href="section10.04.html">4. Parametric Equations</a></li>
<li><a href="section10.05.html">5. Calculus with Parametric Equations</a></li>
</ul>

<h2 class="link"><img id="chapter_11_button" src="expand_submenu.png" onclick='toggle("chapter_11_contents")'><a href="chapter11.html">11 Sequences and Series</a></h2>

<ul class="list" id="chapter_11_contents">
<li><a href="section11.01.html">1. Sequences</a></li>
<li><a href="section11.02.html">2. Series</a></li>
<li><a href="section11.03.html">3. The Integral Test</a></li>
<li><a href="section11.04.html">4. Alternating Series</a></li>
<li><a href="section11.05.html">5. Comparison Tests</a></li>
<li><a href="section11.06.html">6. Absolute Convergence</a></li>
<li><a href="section11.07.html">7. The Ratio and Root Tests</a></li>
<li><a href="section11.08.html">8. Power Series</a></li>
<li><a href="section11.09.html">9. Calculus with Power Series</a></li>
<li><a href="section11.10.html">10. Taylor Series</a></li>
<li><a href="section11.11.html">11. Taylor's Theorem</a></li>
<li><a href="section11.12.html">12. Additional exercises</a></li>
</ul>

<h2 class="link"><img id="chapter_12_button" src="expand_submenu.png" onclick='toggle("chapter_12_contents")'><a href="chapter12.html">12 Three Dimensions</a></h2>

<ul class="list" id="chapter_12_contents">
<li><a href="section12.01.html">1. The Coordinate System</a></li>
<li><a href="section12.02.html">2. Vectors</a></li>
<li><a href="section12.03.html">3. The Dot Product</a></li>
<li><a href="section12.04.html">4. The Cross Product</a></li>
<li><a href="section12.05.html">5. Lines and Planes</a></li>
<li><a href="section12.06.html">6. Other Coordinate Systems</a></li>
</ul>

<h2 class="link"><img id="chapter_13_button" src="expand_submenu.png" onclick='toggle("chapter_13_contents")'><a href="chapter13.html">13 Vector Functions</a></h2>

<ul class="list" id="chapter_13_contents">
<li><a href="section13.01.html">1. Space Curves</a></li>
<li><a href="section13.02.html">2. Calculus with vector functions</a></li>
<li><a href="section13.03.html">3. Arc length and curvature</a></li>
<li><a href="section13.04.html">4. Motion along a curve</a></li>
</ul>

<h2 class="link"><img id="chapter_14_button" src="expand_submenu.png" onclick='toggle("chapter_14_contents")'><a href="chapter14.html">14 Partial Differentiation</a></h2>

<ul class="list" id="chapter_14_contents">
<li><a href="section14.01.html">1. Functions of Several Variables</a></li>
<li><a href="section14.02.html">2. Limits and Continuity</a></li>
<li><a href="section14.03.html">3. Partial Differentiation</a></li>
<li><a href="section14.04.html">4. The Chain Rule</a></li>
<li><a href="section14.05.html">5. Directional Derivatives</a></li>
<li><a href="section14.06.html">6. Higher order derivatives</a></li>
<li><a href="section14.07.html">7. Maxima and minima</a></li>
<li><a href="section14.08.html">8. Lagrange Multipliers</a></li>
</ul>

<h2 class="link"><img id="chapter_15_button" src="expand_submenu.png" onclick='toggle("chapter_15_contents")'><a href="chapter15.html">15 Multiple Integration</a></h2>

<ul class="list" id="chapter_15_contents">
<li><a href="section15.01.html">1. Volume and Average Height</a></li>
<li><a href="section15.02.html">2. Double Integrals in Cylindrical Coordinates</a></li>
<li><a href="section15.03.html">3. Moment and Center of Mass</a></li>
<li><a href="section15.04.html">4. Surface Area</a></li>
<li><a href="section15.05.html">5. Triple Integrals</a></li>
<li><a href="section15.06.html">6. Cylindrical and Spherical Coordinates</a></li>
<li><a href="section15.07.html">7. Change of Variables</a></li>
</ul>

<h2 class="link"><img id="chapter_16_button" src="expand_submenu.png" onclick='toggle("chapter_16_contents")'><a href="chapter16.html">16 Vector Calculus</a></h2>

<ul class="list" id="chapter_16_contents">
<li><a href="section16.01.html">1. Vector Fields</a></li>
<li><a href="section16.02.html">2. Line Integrals</a></li>
<li><a href="section16.03.html">3. The Fundamental Theorem of Line Integrals</a></li>
<li><a href="section16.04.html">4. Green's Theorem</a></li>
<li><a href="section16.05.html">5. Divergence and Curl</a></li>
<li><a href="section16.06.html">6. Vector Functions for Surfaces</a></li>
<li><a href="section16.07.html">7. Surface Integrals</a></li>
<li><a href="section16.08.html">8. Stokes's Theorem</a></li>
<li><a href="section16.09.html">9. The Divergence Theorem</a></li>
</ul>

<h2 class="link"><img id="chapter_17_button" src="expand_submenu.png" onclick='toggle("chapter_17_contents")'><a href="chapter17.html">17 Differential Equations</a></h2>

<ul class="list" id="chapter_17_contents">
<li><a href="section17.01.html">1. First Order Differential Equations</a></li>
<li><a href="section17.02.html">2. First Order Homogeneous Linear Equations</a></li>
<li><a href="section17.03.html">3. First Order Linear Equations</a></li>
<li><a href="section17.04.html">4. Approximation</a></li>
<li><a href="section17.05.html">5. Second Order Homogeneous Equations</a></li>
<li><a href="section17.06.html">6. Second Order Linear Equations</a></li>
<li><a href="section17.07.html">7. Second Order Linear Equations, take two</a></li>
</ul>

<h2 class="link"><img id="chapter_18_button" src="expand_submenu.png" onclick='toggle("chapter_18_contents")'><a href="chapter18.html">18 Useful formulas</a></h2>

<ul class="list" id="chapter_18_contents">
</ul>

</div>

<div id="main">

<div id="next"><a href="chapter13.html"><img src=previous_section.png width="30"></a>&nbsp;&nbsp;<a href="section13.02.html"><img src=next_section.png width="30"></a></div>

<div id="content">
<p>


</p><p>
We have already seen that a convenient way to describe a line in three
dimensions is to provide a vector that "points to'' every point on
the line as a parameter $t$ varies, like
$$\langle 1,2,3\rangle+t\langle 1,-2,2\rangle
=\langle 1+t,2-2t,3+2t\rangle.$$
Except that this gives a particularly simple geometric object, there
is nothing special about the individual functions of $t$ that make up
the coordinates of this vector&mdash;any vector with a parameter, like
$\langle f(t),g(t),h(t)\rangle$, will describe some curve in three
dimensions as $t$ varies through all possible values. 
</p><p>
</p>
<div class="example">
<p>
<span class="theoremlabel">Example 13.1.1 </span>Describe the curves
$\langle \cos t,\sin t,0\rangle$,
$\langle \cos t,\sin t,t\rangle$, and
$\langle \cos t,\sin t,2t\rangle$.
<a id="exam:helixes"></a>
</p><p>
As $t$ varies, the first two coordinates in all three functions
trace out the points on the unit circle, starting
with $(1,0)$ when $t=0$ and proceeding counter-clockwise around the
circle as $t$ increases. In the first case, the $z$ coordinate is
always 0, so this describes precisely the unit circle in the $x$-$y$
plane. In the second case, the $x$ and $y$ coordinates still describe
a circle, but now 
the $z$ coordinate varies, so that the
height of the curve matches the value of $t$. When $t=\pi$, for
example, the resulting vector is $\langle -1,0,\pi\rangle$. A bit of
thought should convince you that the result is a helix. In the third
vector, the $z$ coordinate varies twice as fast as the parameter $t$,
so we get a stretched out helix. Both are shown in
figure <a href="section13.01.html#fig:helixes">13.1.1</a>. On the left is the first helix, shown for
$t$ between 0 and $4\pi$; on the right is the second helix, shown for
$t$ between 0 and $2\pi$. Both start and end at the same point, but
the first helix takes two full "turns'' to get there, because its $z$
coordinate grows more slowly.

</p>
</div><!-- example -->
<p>
</p><p>
<a id="fig:helixes"></a>
</p><div class='figure'><!-- Vector_Functions_two_helixes.html -->
<!-- Figure 13.1.1 -->
<table class="webgl_display" style="margin-left:auto;margin-right:auto;display:none">
  <tr>
    <td id='helix_1'>
    </td>
    <td id='helix_2'>
    </td>
  </tr>
</table>

<table class="no_webgl_display" style="margin-left:auto;margin-right:auto;display:block">
  <tr>
    <td style="text-align:center">
      <a href="https://www.whitman.edu/mathematics/calculus_applets/helixes">
	<img src="images/helix1.png" width=300>
    </a></td>
    <td style="text-align:center">
      <a href="https://www.whitman.edu/mathematics/calculus_applets/helixes">
	<img src="images/helix2.png" width=300>
    </a></td>
</tr></table>
<script>
    MathJax.Hub.Register.StartupHook("End",function(){
	var SCREEN_WIDTH = 400, SCREEN_HEIGHT = 400;
	var container, scene, camera, renderer, controls;
	var keyboard = new THREEx.KeyboardState();
	var clock = new THREE.Clock();
	var xoffset = 0, yoffset = 0, zoffset = -Math.PI/2;
	var meshFunction;
	
	var xMin = xMax = yMin = yMax = 0; // for autosizing window
	
	
	if(typeof window.orientation === 'undefined') {
	    init();
	    animate();
	}
	
	function init() 
	{
	    scene = new THREE.Scene();
	    if ( Detector.webgl )
		renderer = new THREE.WebGLRenderer( {alpha:true, antialias:true} );
	    else
		renderer = new THREE.CanvasRenderer(); 
	    renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
	    container = document.getElementById( 'helix_1' );
	    container.appendChild( renderer.domElement );
	    var light = new THREE.PointLight(0xffffff,1,100);
	    light.position.set(3,3,10);
	    scene.add(light);
	    var light_amb = new THREE.AmbientLight( 0xaaaaaa ); // soft white light
	    scene.add( light_amb );
	    var spritex = makeTextSprite( "x", { fontsize: 30, borderColor: {r:0, g:0, b:255, a:1.0}, xoffset:-15 } );
	    spritex.position.set(1,0,0+zoffset);
	    scene.add( spritex );
	    var spritey = makeTextSprite( "y", { fontsize: 30, borderColor: {r:0, g:0, b:255, a:1.0} } );
	    spritey.position.set(0,1,0+zoffset);
	    scene.add( spritey );
	    var spritez = makeTextSprite( "z", { fontsize: 30, borderColor: {r:0, g:0, b:255, a:1.0}, yoffset:-10 } );
	    spritez.position.set(0,0,Math.PI+zoffset);
	    scene.add( spritez );
	    
	    var axes = buildAxes();
	    scene.add(axes);
	    plot_it_1();
	    //	    plot_it_2();
	    resetCamera();
	}
	
	function makeTextSprite(message, opts) {
	    var parameters = opts || {};
	    var fontface = parameters.fontface || 'Helvetiker';
	    var fontsize = parameters.fontsize || 70;
	    var borderThickness = parameters.borderThickness || 1;
	    var xoffset = parameters.xoffset || 0;
	    var yoffset = parameters.yoffset || 0;
	    var canvas = document.createElement('canvas');
	    canvas.width = canvas.height = 200;
	    var context = canvas.getContext('2d');
	    context.font = fontsize + "px " + fontface;
	    
	    // get size data (height depends only on font size)
	    var metrics = context.measureText(message);
	    var textWidth = metrics.width;
	    
	    // text color
	    context.fillStyle = 'rgba(0, 0, 0, 1.0)';
	    context.fillText(message, canvas.width/2+xoffset, canvas.width/2+yoffset);
	    //	    alert(canvas.width);
	    // canvas contents will be used for a texture
	    var texture = new THREE.Texture(canvas)
	    texture.minFilter = THREE.LinearFilter;
	    texture.needsUpdate = true;
	    //roundRect(context, borderThickness, borderThickness, textWidth + 2 * borderThickness, fontsize * 1.4 + 2* borderThickness, 6);
	    var spriteMaterial = new THREE.SpriteMaterial({
		map: texture
		//              useScreenCoordinates: false
	    });
	    var sprite = new THREE.Sprite(spriteMaterial);
	    sprite.scale.set(1,1,1);
	    return sprite;
	}
	
	
	function resetCamera()
	{
	    var VIEW_ANGLE = 15, ASPECT = SCREEN_WIDTH / SCREEN_HEIGHT, NEAR = 0.1, FAR = 20000;
	    // Orthog camera
	    camera = new THREE.OrthographicCamera( 1.5*zoffset*ASPECT,-1.5*zoffset*ASPECT,-1.5*zoffset,1.5*zoffset, NEAR, FAR);
	    var zoom = 3;
	    camera.position.x = zoom*3;
	    camera.position.y = zoom*3;
	    camera.position.z = zoom*3;
	    // Perspective camera
	    // camera = new THREE.PerspectiveCamera( VIEW_ANGLE, ASPECT, NEAR, FAR);
	    // scene.add(camera);
	    // camera.position.set(10,10,10);
	    // camera.lookAt(scene.position);  
	    
	    camera.up.set( 0, 0, 1 ); 
	    scene.add(camera);
	    controls = new THREE.TrackballControls( camera, renderer.domElement );
	    controls.rotateSpeed = 1;
	    THREEx.WindowResize(renderer, camera);
	}
	
	function animate() 
	{
	    requestAnimationFrame( animate );
	    if ($('#helix_1').visible(true) && active ) {
		render();
		update();
	    }
	}
	
	function update()
	{
	    if ( keyboard.pressed("z") ) 
	    { 
		// do something
	    }
	    
	    controls.update();
	    //	stats.update();
	}
	
	function render() 
	{
	    renderer.render( scene, camera );
	}
	
	
	function plot_it_1()
	{
	    function x(t) {
		return Math.cos(t);
	    }
	    function y(t) {
		return Math.sin(t);
	    }
	    function z(t) {
		return t/4+zoffset;
	    }
	    curveGraph(x,y,z,0,4*Math.PI,50,new THREE.Color( 0xff0000 ));
	}
	
	function plot_it_2()
	{
	    function x(t) {
		return -(1+2*Math.cos(t)+Math.sqrt(2)*Math.sin(t))/Math.sqrt(2);
	    }
	    function y(t) {
		return (-1-2*Math.cos(t)+Math.sqrt(2)*Math.sin(t))/Math.sqrt(2);
	    }
	    function z(t) {
		return Math.PI/4+Math.sqrt(2)*Math.sin(t);
	    }
	    curveGraph(x,y,z,0,2*Math.PI,30,new THREE.Color( 0x0000ff ));
	}
	
	function curveGraph(xFunc,yFunc,zFunc,tMin,tMax,segments,color)
	{
	    var normMaterial = new THREE.MeshBasicMaterial( { vertexColors: THREE.VertexColors,side:THREE.DoubleSide } );
	    var graphMesh;
	    var tRange = tMax - tMin;
	    var  mycurve = THREE.Curve.create( 
		function() {},
		function(t) 
		{
		    // default:    0 < t < 1
		    //    want: tMin < t < tMax
		    t = t * tRange + tMin;
		    return new THREE.Vector3(xFunc(t), yFunc(t), zFunc(t)).multiplyScalar(1);
		}
	    );
	    var curve = new mycurve;
	    
	    var closedTube = false;
	    var debug = false; // show normal vectors
	    var tubeGeometry = new THREE.TubeGeometry(curve, segments, 0.01, 3, false, debug);
	    
	    var  point, face, numberOfSides;
	    for ( var i = 0; i < tubeGeometry.faces.length; i++ ) 
	    {
		face = tubeGeometry.faces[ i ];
		numberOfSides = ( face instanceof THREE.Face3 ) ? 3 : 4;
		for( var j = 0; j < numberOfSides; j++ ) 
		{
		    face.vertexColors[ j ] = color;
		}
	    }
	    
	    // for auto-sizing window
	    tubeGeometry.computeBoundingBox();
	    xMin = tubeGeometry.boundingBox.min.x;
	    xMax = tubeGeometry.boundingBox.max.x;
	    yMin = tubeGeometry.boundingBox.min.y;
	    yMax = tubeGeometry.boundingBox.max.y;
	    zMin = tubeGeometry.boundingBox.min.z;
	    zMax = tubeGeometry.boundingBox.max.z;
	    
	    if (graphMesh) 
	    {
		scene.remove( graphMesh );
		// renderer.deallocateObject( graphMesh );
	    }
	    
	    graphMesh = new THREE.Mesh( tubeGeometry, normMaterial );
	    graphMesh.doubleSided = true;
	    scene.add(graphMesh);
	}
	
	function buildAxes() {
	    var axes = new THREE.Object3D();
	    
	    axes.add( buildAxis( new THREE.Vector3( 0, 0, zoffset ), new THREE.Vector3( 1, 0, zoffset ), 0x000000, false ) ); // +X
	    axes.add( buildAxis( new THREE.Vector3( 0, 0, zoffset ), new THREE.Vector3( -1, 0, zoffset ), 0x000000, true) ); // -X
	    axes.add( buildAxis( new THREE.Vector3( 0, 0, zoffset ), new THREE.Vector3( 0, 1, zoffset ), 0x000000, false ) ); // +Y
	    axes.add( buildAxis( new THREE.Vector3( 0, 0, zoffset ), new THREE.Vector3( 0, -1, zoffset ), 0x000000, true ) ); // -Y
	    axes.add( buildAxis( new THREE.Vector3( 0, 0, zoffset ), new THREE.Vector3( 0, 0, Math.PI+zoffset ), 0x000000, false ) ); // +Z
	    //	    axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 0, -length ), 0x0000FF, true ) ); // -Z
	    return axes;
	}	
	
	function buildAxis( src, dst, colorHex, dashed ) {
	    var geom = new THREE.Geometry();
	    var mat;
	    
	    if(dashed) {
		mat = new THREE.LineDashedMaterial({ linewidth: 1, color: colorHex, dashSize: 0.05, gapSize: 0.05 });
	    } else {
		mat = new THREE.LineBasicMaterial({ linewidth: 1, color: colorHex });
	    }
	    
	    geom.vertices.push( src.clone() );
	    geom.vertices.push( dst.clone() );
	    geom.computeLineDistances();
	    
	    var axis = new THREE.Line( geom, mat );
	    
	    return axis;
	}
    });
  
  MathJax.Hub.Register.StartupHook("End",function(){
      var SCREEN_WIDTH = 400, SCREEN_HEIGHT = 400;
      var container, scene, camera, renderer, controls;
      var keyboard = new THREEx.KeyboardState();
      var clock = new THREE.Clock();
      var xoffset = 0, yoffset = 0, zoffset = -Math.PI/2;
      var meshFunction;
      
      var xMin = xMax = yMin = yMax = 0; // for autosizing window
      
      
      if(typeof window.orientation === 'undefined') {
	  init();
	  animate();
      }
      
      function init() 
      {
	  scene = new THREE.Scene();
	  if ( Detector.webgl )
	      renderer = new THREE.WebGLRenderer( {alpha:true, antialias:true} );
	  else
	      renderer = new THREE.CanvasRenderer(); 
	  renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
	  container = document.getElementById( 'helix_2' );
	  container.appendChild( renderer.domElement );
	  var light = new THREE.PointLight(0xffffff,1,100);
	  light.position.set(3,3,10);
	  scene.add(light);
	  var light_amb = new THREE.AmbientLight( 0xaaaaaa ); // soft white light
	  scene.add( light_amb );
	  
	  var axes = buildAxes();
	  scene.add(axes);
	  var spritex = makeTextSprite( "x", { fontsize: 30, borderColor: {r:0, g:0, b:255, a:1.0}, xoffset:-15 } );
	  spritex.position.set(1,0,0+zoffset);
	  scene.add( spritex );
	  var spritey = makeTextSprite( "y", { fontsize: 30, borderColor: {r:0, g:0, b:255, a:1.0} } );
	  spritey.position.set(0,1,0+zoffset);
	  scene.add( spritey );
	  var spritez = makeTextSprite( "z", { fontsize: 30, borderColor: {r:0, g:0, b:255, a:1.0}, yoffset:-10 } );
	  spritez.position.set(0,0,Math.PI+zoffset);
	  scene.add( spritez );
	  
	  plot_it_1();
	  //	    plot_it_2();
	  resetCamera();
      }
      
      
      function makeTextSprite(message, opts) {
	  var parameters = opts || {};
	  var fontface = parameters.fontface || 'Helvetiker';
	  var fontsize = parameters.fontsize || 70;
	  var borderThickness = parameters.borderThickness || 1;
	  var xoffset = parameters.xoffset || 0;
	  var yoffset = parameters.yoffset || 0;
	  var canvas = document.createElement('canvas');
	  canvas.width = canvas.height = 200;
	  var context = canvas.getContext('2d');
	  context.font = fontsize + "px " + fontface;
	  
	  // get size data (height depends only on font size)
	  var metrics = context.measureText(message);
	  var textWidth = metrics.width;
	  
	  // text color
	  context.fillStyle = 'rgba(0, 0, 0, 1.0)';
	  context.fillText(message, canvas.width/2+xoffset, canvas.width/2+yoffset);
	  //	    alert(canvas.width);
	  // canvas contents will be used for a texture
	  var texture = new THREE.Texture(canvas)
	  texture.minFilter = THREE.LinearFilter;
	  texture.needsUpdate = true;
	  //roundRect(context, borderThickness, borderThickness, textWidth + 2 * borderThickness, fontsize * 1.4 + 2* borderThickness, 6);
	  var spriteMaterial = new THREE.SpriteMaterial({
	      map: texture
	      //              useScreenCoordinates: false
	  });
	  var sprite = new THREE.Sprite(spriteMaterial);
	  sprite.scale.set(1,1,1);
	  return sprite;
      }
      
      
      // function for drawing rounded rectangles
      function roundRect(ctx, x, y, w, h, r) 
      {
	  ctx.beginPath();
	  ctx.moveTo(x+r, y);
	  ctx.lineTo(x+w-r, y);
	  ctx.quadraticCurveTo(x+w, y, x+w, y+r);
	  ctx.lineTo(x+w, y+h-r);
	  ctx.quadraticCurveTo(x+w, y+h, x+w-r, y+h);
	  ctx.lineTo(x+r, y+h);
	  ctx.quadraticCurveTo(x, y+h, x, y+h-r);
	  ctx.lineTo(x, y+r);
	  ctx.quadraticCurveTo(x, y, x+r, y);
	  ctx.closePath();
	  //	 ctx.fill();
	  ctx.stroke();   
      }
      
      function resetCamera()
      {
	  var VIEW_ANGLE = 15, ASPECT = SCREEN_WIDTH / SCREEN_HEIGHT, NEAR = 0.1, FAR = 20000;
	  // Orthog camera
	  camera = new THREE.OrthographicCamera( 1.5*zoffset*ASPECT,-1.5*zoffset*ASPECT,-1.5*zoffset,1.5*zoffset, NEAR, FAR );
	  var zoom = 3;
	  camera.position.x = zoom*3;
	  camera.position.y = zoom*3;
	  camera.position.z = zoom*3;
	  // Perspective camera
	  // camera = new THREE.PerspectiveCamera( VIEW_ANGLE, ASPECT, NEAR, FAR);
	  // scene.add(camera);
	  // camera.position.set(10,10,10);
	  // camera.lookAt(scene.position);  
	  
	  camera.up.set( 0, 0, 1 ); 
	  scene.add(camera);
	  controls = new THREE.TrackballControls( camera, renderer.domElement );
	  controls.rotateSpeed = 1;
	  THREEx.WindowResize(renderer, camera);
      }
      
      function animate() 
      {
	  requestAnimationFrame( animate );
	  if ($('#helix_2').visible(true) && active ) {
	      render();
	      update();
	  }
      }
      function update()
      {
	  if ( keyboard.pressed("z") ) 
	  { 
	      // do something
	  }
	  
	  controls.update();
	  //	stats.update();
      }
      
      function render() 
      {
	  renderer.render( scene, camera );
      }
      
      
      function plot_it_1()
      {
	  function x(t) {
	      return Math.cos(t);
	  }
	  function y(t) {
	      return Math.sin(t);
	  }
	  function z(t) {
	      return 2*t/4+zoffset;
	  }
	  curveGraph(x,y,z,0,2*Math.PI,50,new THREE.Color( 0xff0000 ));
      }
      
      function plot_it_2()
      {
	  function x(t) {
	      return -(1+2*Math.cos(t)+Math.sqrt(2)*Math.sin(t))/Math.sqrt(2);
	  }
	  function y(t) {
	      return (-1-2*Math.cos(t)+Math.sqrt(2)*Math.sin(t))/Math.sqrt(2);
	  }
	  function z(t) {
	      return Math.PI/4+Math.sqrt(2)*Math.sin(t);
	  }
	  curveGraph(x,y,z,0,2*Math.PI,30,new THREE.Color( 0x0000ff ));
      }
      
      function curveGraph(xFunc,yFunc,zFunc,tMin,tMax,segments,color)
      {
	  var normMaterial = new THREE.MeshBasicMaterial( { vertexColors: THREE.VertexColors,side:THREE.DoubleSide } );
	  var graphMesh;
	  var tRange = tMax - tMin;
	  var  mycurve = THREE.Curve.create( 
	      function() {},
	      function(t) 
	      {
		  // default:    0 < t < 1
		  //    want: tMin < t < tMax
		  t = t * tRange + tMin;
		  return new THREE.Vector3(xFunc(t), yFunc(t), zFunc(t)).multiplyScalar(1);
	      }
	  );
	  var curve = new mycurve;
	  
	  var closedTube = false;
	  var debug = false; // show normal vectors
	  var tubeGeometry = new THREE.TubeGeometry(curve, segments, 0.01, 3, false, debug);
	  
	  var  point, face, numberOfSides;
	  for ( var i = 0; i < tubeGeometry.faces.length; i++ ) 
	  {
	      face = tubeGeometry.faces[ i ];
	      numberOfSides = ( face instanceof THREE.Face3 ) ? 3 : 4;
	      for( var j = 0; j < numberOfSides; j++ ) 
	      {
		  face.vertexColors[ j ] = color;
	      }
	  }
	  
	  // for auto-sizing window
	  tubeGeometry.computeBoundingBox();
	  xMin = tubeGeometry.boundingBox.min.x;
	  xMax = tubeGeometry.boundingBox.max.x;
	  yMin = tubeGeometry.boundingBox.min.y;
	  yMax = tubeGeometry.boundingBox.max.y;
	  zMin = tubeGeometry.boundingBox.min.z;
	  zMax = tubeGeometry.boundingBox.max.z;
	  
	  if (graphMesh) 
	  {
	      scene.remove( graphMesh );
	      // renderer.deallocateObject( graphMesh );
	  }
	  
	  graphMesh = new THREE.Mesh( tubeGeometry, normMaterial );
	  graphMesh.doubleSided = true;
	  scene.add(graphMesh);
      }
      
      function buildAxes() {
	  var axes = new THREE.Object3D();
	  
	  axes.add( buildAxis( new THREE.Vector3( 0, 0, zoffset ), new THREE.Vector3( 1, 0, zoffset ), 0x000000, false ) ); // +X
	  axes.add( buildAxis( new THREE.Vector3( 0, 0, zoffset ), new THREE.Vector3( -1, 0, zoffset ), 0x000000, true) ); // -X
	  axes.add( buildAxis( new THREE.Vector3( 0, 0, zoffset ), new THREE.Vector3( 0, 1, zoffset ), 0x000000, false ) ); // +Y
	  axes.add( buildAxis( new THREE.Vector3( 0, 0, zoffset ), new THREE.Vector3( 0, -1, zoffset ), 0x000000, true ) ); // -Y
	  axes.add( buildAxis( new THREE.Vector3( 0, 0, zoffset ), new THREE.Vector3( 0, 0, Math.PI+zoffset ), 0x000000, false ) ); // +Z
	  //	    axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 0, -length ), 0x0000FF, true ) ); // -Z
	  return axes;
      }	
      
      function buildAxis( src, dst, colorHex, dashed ) {
	  var geom = new THREE.Geometry();
	  var mat;
	  
	  if(dashed) {
	      mat = new THREE.LineDashedMaterial({ linewidth: 1, color: colorHex, dashSize: 0.05, gapSize: 0.05 });
	  } else {
	      mat = new THREE.LineBasicMaterial({ linewidth: 1, color: colorHex });
	  }
	  
	  geom.vertices.push( src.clone() );
	  geom.vertices.push( dst.clone() );
	  geom.computeLineDistances();
	  
	  var axis = new THREE.Line( geom, mat );
	  
	  return axis;
      }
      
  });
</script>  

<div class='figcaption'><span class="figurenumber">Figure 13.1.1.</span> Two helixes.</div></div>
<p>
</p><p>
A vector expression of the form $\langle f(t),g(t),h(t)\rangle$ is called
a <b>vector function</b>; it is a function from
the real numbers $\R$ to the set of all three-dimensional vectors.
We can alternately think of it as three separate functions, 
$x=f(t)$, $y=g(t)$, and $z=h(t)$, that describe points in space. In
this case we usually refer to the set of equations as <b>parametric equations</b> for the curve, just
as for a line. While the parameter $t$ in a vector function might
represent any one of a number of physical quantities, or be simply a
"pure number'', it is often convenient and useful to think of $t$ as
representing time. The vector function then tells you where in space
a particular object is at any time.
</p><p>
Vector functions can be difficult to understand, that is, difficult to
picture. When available, computer software can be very helpful. When
working by hand, one useful approach is to consider the
"projections'' of the curve onto the three standard coordinate
planes. We have already done this in part: in
example <a href="section13.01.html#exam:helixes">13.1.1</a> we noted that all three curves project to
a circle in the $x$-$y$ plane, since $\langle \cos t,\sin t\rangle$ is
a two dimensional vector function for the unit circle.
</p><p>
</p>
<div class="example">
<p>
<span class="theoremlabel">Example 13.1.2 </span>Graph the projections of $\langle \cos t,\sin
t,2t\rangle$ onto the $x$-$z$ plane and the $y$-$z$ plane.
The two dimensional vector function for the
projection onto the $x$-$z$ plane is $\langle \cos t, 2t\rangle$, or in
parametric form, $x=\cos t$, $z=2t$. By eliminating $t$ we get the
equation $x=\cos(z/2)$, the familiar curve shown on the left in
figure <a href="section13.01.html#fig:helix projections">13.1.2</a>. For the projection onto the $y$-$z$ plane, we start
with the vector function $\langle \sin t, 2t\rangle$, which is the
same as $y=\sin t$, $z=2t$. Eliminating $t$ gives $y=\sin(z/2)$, as
shown on the right in figure <a href="section13.01.html#fig:helix projections">13.1.2</a>.

</p>
</div><!-- example -->
<p>
</p><p>

<a id="fig:helix projections"></a>
</p><div class='figure'><!-- Vector_Functions_helix_projections.html -->
<!-- Figure 13.1.2 -->

<table style="width:80%;margin-left:auto;margin-right:auto">
<tr style="width:100%">
<td style="width:50%">
<div id='x_z_projection' class='jxgbox'></div>
</td><td style="width:50%">
<div id='y_z_projection' class='jxgbox'></div>
</td>
</tr></table>

<script type='text/javascript'>
(function () {  // BEGIN: scope limiting function wrapper
  var xmin=-1.5, xmax= 1.5, ymin=-1.5, ymax=9/2*Math.PI+1;
  var AspectRatio =  (3/2); // height/width
  var wd=document.getElementById('x_z_projection').offsetWidth;
  var ht=wd*AspectRatio;
  var yfactor = (ymax-ymin)/(ht);
  var xfactor = (xmax-xmin)/(wd);
  var xaxis_label_offset = yfactor*15;
  var yaxis_label_offset = xfactor*20;
  document.getElementById('x_z_projection').style.height=ht+'px';
  var brd = JXG.JSXGraph.initBoard('x_z_projection',{boundingbox:[xmin,ymax,xmax,ymin], showCopyright:false, showNavigation:false}) ;
  var rejax = function() {
     MathJax.Hub.Queue(["Typeset",MathJax.Hub]); 
  }
  brd.addHook(rejax)
  var xaxis = brd.create('arrow', [[-1.2,0], [1.2,0]],{strokeWidth:1,strokeColor:'black',fixed:true});
  var yaxis = brd.create('arrow', [[0,0],[0,9/2*Math.PI]],{strokeWidth:1,strokeColor:'black',fixed:true});
  var xi = brd.create('segment',[[-2,0],[1.1,0]],{visible:false});
  brd.create('ticks',[xi,1],{minorTicks:false});
  var yi = brd.create('segment',[[0,0],[0,4*Math.PI+0.1]],{visible:false});
  brd.create('ticks',[yi,2*Math.PI],{minorTicks:false});
  var i;
  brd.create('text',[-yaxis_label_offset-xfactor*0,2*Math.PI,'$2\\\\pi$'],{fixed:true});
  brd.create('text',[-yaxis_label_offset-xfactor*0,4*Math.PI,'$4\\\\pi$'],{fixed:true});
  brd.create('text',[-1,0-xaxis_label_offset,'$-1$'],{fixed:true});
  brd.create('text',[1,0-xaxis_label_offset,'$1$'],{fixed:true});
  brd.create('text',[0,9/2*Math.PI+yfactor*5,'$z$'],{fixed:true});
  brd.create('text',[1.2+xfactor*5,0,'$x$'],{fixed:true});
  brd.create('curve',[
   function(t) { return (Math.cos(t)); }, 
   function(t) { return (2*t); },
   0,2*Math.PI],{strokeWidth:2}); 
})(); // END: scope limiting function wrapper
</script>

<script type='text/javascript'>
(function () {  // BEGIN: scope limiting function wrapper
  var xmin=-1.5, xmax= 1.5, ymin=-1.5, ymax=9/2*Math.PI+1;
  var AspectRatio =  (3/2); // height/width
  var wd=document.getElementById('y_z_projection').offsetWidth;
  var ht=wd*AspectRatio;
  var yfactor = (ymax-ymin)/(ht);
  var xfactor = (xmax-xmin)/(wd);
  var xaxis_label_offset = yfactor*15;
  var yaxis_label_offset = xfactor*20;
  document.getElementById('y_z_projection').style.height=ht+'px';
  var brd = JXG.JSXGraph.initBoard('y_z_projection',{boundingbox:[xmin,ymax,xmax,ymin], showCopyright:false, showNavigation:false}) ;
  var rejax = function() {
     MathJax.Hub.Queue(["Typeset",MathJax.Hub]); 
  }
  brd.addHook(rejax)
  var xaxis = brd.create('arrow', [[-1.2,0], [1.2,0]],{strokeWidth:1,strokeColor:'black',fixed:true});
  var yaxis = brd.create('arrow', [[0,0],[0,9/2*Math.PI]],{strokeWidth:1,strokeColor:'black',fixed:true});
  var xi = brd.create('segment',[[-2,0],[1.1,0]],{visible:false});
  brd.create('ticks',[xi,1],{minorTicks:false});
  var yi = brd.create('segment',[[0,0],[0,4*Math.PI+0.1]],{visible:false});
  brd.create('ticks',[yi,2*Math.PI],{minorTicks:false});
  var i;
  brd.create('text',[-yaxis_label_offset-xfactor*0,2*Math.PI,'$2\\\\pi$'],{fixed:true});
  brd.create('text',[-yaxis_label_offset-xfactor*0,4*Math.PI,'$4\\\\pi$'],{fixed:true});
  brd.create('text',[-1,0-xaxis_label_offset,'$-1$'],{fixed:true});
  brd.create('text',[1,0-xaxis_label_offset,'$1$'],{fixed:true});
  brd.create('text',[0,9/2*Math.PI+yfactor*5,'$z$'],{fixed:true});
  brd.create('text',[1.2+xfactor*5,0,'$y$'],{fixed:true});
   brd.create('curve',[
    function(t) { return (Math.sin(t)); }, 
    function(t) { return (2*t); },
    0,2*Math.PI],{strokeWidth:2}); 
})(); // END: scope limiting function wrapper
</script>
<div class='figcaption'><span class="figurenumber">Figure 13.1.2.</span> The projections of $\langle \cos t,\sin
t,2t\rangle$ onto the $x$-$z$ and $y$-$z$ planes.</div></div>
<p>
</p><p>
</p>
<a id="exercises"></a><h2 class="exercises">Exercises 13.1</h2>
<p></p><p>
You can use Sage to graph spacecurves to check your work:
</p><p><div class='figure'><!--  -->
<!-- 13.1 -->
<script>
$(function () {sagecell.makeSagecell({inputLocation: '#spacecurve', linked: false});});
</script>
<div id="spacecurve"><script type="text/code">
t=var('t');
r=vector([cos(t),sin(t),t]);
parametric_plot3d(r,(t,0,2*pi),plot_points=100,perspective_depth=false,color="red",thickness=2);</script></div>
<!--
parametric_plot3d(r,(t,0,2*pi), plot_points=100,perspective_depth=false,color="red",thickness=2,viewer='threejs');</script></div>
-->

</div></p><p></p><p>
</p>
<p class="exercise"><b>Ex 13.1.1</b>
Describe the curve ${\bf r}=\langle \sin t,\cos t,\cos
8t\rangle$.

</p><p>
</p>
<p class="exercise"><b>Ex 13.1.2</b>
Describe the curve 
${\bf r}=\langle t\cos t,t\sin t,t\rangle$.

</p><p>
</p>
<p class="exercise"><b>Ex 13.1.3</b>
Describe the curve 
${\bf r}=\langle t,t^2,\cos t\rangle$.

</p><p>
</p>
<p class="exercise"><b>Ex 13.1.4</b>
Describe the curve 
${\bf r}=\langle \cos(20t)\sqrt{1-t^2},\sin(20t)\sqrt{1-t^2},t\rangle$

</p><p>
</p>
<p class="exercise"><b>Ex 13.1.5</b>
Find a vector function for the curve of intersection of
$x^2+y^2=9$ and $y+z=2$.
(<a knowl="" class="internal" value="$\langle 3\cos t, 3\sin t, 2-3\sin t\rangle$">answer</a>)


</p><p>
</p>
<p class="exercise"><b>Ex 13.1.6</b>
A bug is crawling outward along the spoke of a wheel that lies along
a radius of the wheel. The bug is crawling at 1 unit per second and
the wheel is rotating at 1 radian per second. Suppose the wheel lies
in the $y$-$z$ plane with center at the origin, and at time $t=0$ the
spoke lies along the positive $y$ axis and the bug is at the origin.
Find a vector function ${\bf r}(t)$
for the position of the bug at time $t$.
(<a knowl="" class="internal" value="$\langle 0,t\cos t,t\sin t\rangle$">answer</a>)


</p><p>
</p>
<p class="exercise"><b>Ex 13.1.7</b>
What is the difference between the parametric curves
$f(t)=\langle t, t, t^2 \rangle$, $g(t)=\langle t^2, t^2, t^4
\rangle$, and $h(t)=\langle \sin(t), \sin(t), \sin^2(t) \rangle$as $t$
runs over all real numbers?

</p><p>
</p>
<p class="exercise"><b>Ex 13.1.8</b>
Plot each of the curves below in 2 dimensions, projected
onto each of the three standard planes (the $x$-$y$, $x$-$z$, and
$y$-$z$ planes).
</p><p>
</p><ul><p>
</p><p> a.  $f(t)=\langle t, t^3, t^2 \rangle$, $t$ ranges over all real numbers
</p><p> b.  $f(t)=\langle t^2, t-1, t^2+5 \rangle$  for $0\leq t \leq 3$
</p></ul><p>

</p><p>
</p>
<p class="exercise"><b>Ex 13.1.9</b>
Given points $A=(a_1, a_2, a_3)$ and $B=(b_1, b_2, b_3)$, give
parametric equations for the line <em>segment</em> connecting $A$ and
$B$. Be sure to give appropriate $t$ values.

</p><p>
</p>
<p class="exercise"><b>Ex 13.1.10</b>
With a parametric plot and a set of $t$ values, we can associate
a `direction'.  For example, the curve $\langle \cos t, \sin t
\rangle$ is the unit circle traced counterclockwise.  How can we amend
a set of given parametric equations and $t$ values to get the same
curve, only traced backwards?

</p><p>


</p><p>
</div></div></body>
</html>
