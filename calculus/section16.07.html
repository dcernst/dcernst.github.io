<!DOCTYPE HTML>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
<meta http-equiv="Content-Language" Content="en">
<title>16.7 Surface Integrals</title>
<!--
<script type="text/javascript" src="js/deployJava.js"></script>
<link rel="stylesheet" type="text/css" href="http://jsxgraph.uni-bayreuth.de/distrib/jsxgraph.css" />
-->
<!-- use Jsxgraph to create figures: http://jsxgraph.uni-bayreuth.de/wp/ -->
<link rel="stylesheet" type="text/css" href="css/jsxgraph.css" />
<script type="text/javascript" src="js/jsxgraphcore.js"></script>
<script src="js/three.min.js"></script>
<script src="js/Detector.js"></script>
<script src="js/TrackballControls.js"></script>
<script src="js/OrthographicTrackballControls.js"></script>
<script src="js/THREEx.KeyboardState.js"></script>
<script src="js/THREEx.FullScreen.js"></script>
<script src="js/THREEx.WindowResize.js"></script>
<script type='text/javascript' src='js/DAT.GUI.min.js'></script>
<script>
window.requestAnimFrame = (function(){
    return  window.requestAnimationFrame       || 
        window.webkitRequestAnimationFrame || 
        window.mozRequestAnimationFrame    || 
        window.oRequestAnimationFrame      || 
        window.msRequestAnimationFrame     || 
        function(/* function */ callback, /* DOMElement */
            element){
            window.setTimeout(callback, 1000 / 60);
        };
})();
</script>
<script src="js/ifvisible.min.js"></script>
<script src="js/conrec.js"></script>
<script>
active = true;
ifvisible.setIdleDuration(10);
ifvisible.on("idle", function(){
    active = false;
//    console.log("idle");
});

ifvisible.on("wakeup", function(){
    active = true;
//    console.log("wakeup");
});
</script>
<script src="js/parser.js"></script>
<link href="css/whitman.css" rel="stylesheet" type="text/css" /><link href="css/calculus.css" rel="stylesheet" type="text/css" /><link href="css/knowlstyle.css" rel="stylesheet" type="text/css" />

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js","TeX/AMSmath.js","TeX/AMSsymbols.js"],
  jax: ["input/TeX","output/HTML-CSS"],
  tex2jax: {
    inlineMath: [['$','$'],["\\(","\\)"]],
    processEscapes: true,
  },
TeX: {
   Macros: {
    val: "\\mathop{\\rm val}",
    divides: "\\mid",
    ndivides: "\\mathrel{\\not|}",
    fix: "\\mathop{\\rm fix}",
    id: "\\mathop{\\rm id}",
    na: "\\mathop{\\rm na}",
    d: "\\mathop{\\rm\\strut d}\\nolimits ",
    legendre: ["\\left(\\frac{#1}{#2}\\right)",2],
    normalbaselines: "",
    notdiv: "\\nmid",
    implies: "\\Rightarrow",
    iff: "\\Leftrightarrow",
    sevenpoint: "\\scriptsize",
    ds: "\\displaystyle",
    lcm: "\\operatorname{lcm}",
    arccot: "\\operatorname{arccot}",
    arcsec: "\\operatorname{arcsec}",
    arccsc: "\\operatorname{arccsc}",
    arccosh: "\\operatorname{arccosh}",
    arcsinh: "\\operatorname{arcsinh}",
    arcsech: "\\operatorname{arcsech}",
    sech: "\\operatorname{sech}",
    csch: "\\operatorname{csch}",
    R: "{\\mathbb R}",
    sb: "_",
    sp: "^",
    Q: "{\\mathbb Q}",
    C: "{\\mathbb C}",
    N: "{\\mathbb N}",
    Z: "{\\mathbb Z}",
    U: "{\\mathbb U}",
    v: ["\\langle #1\\rangle",1],
    dint: ["{\\mathchoice{\\mathop{\\int\\!\\!\\!\\int}_{#1}}{\\mathop{\\int\\!\\!\\!\\int}_{#1}}{\\mathop{\\int\\!\\!\\!\\int}}{\\mathop{\\int\\!\\!\\!\\int}}}",1],
    tint: ["{\\mathchoice{\\mathop{\\int\\!\\!\\!\\int\\!\\!\\!\\int}_{#1\\;}}{\\mathop{\\int\\!\\!\\!\\int\\!\\!\\!\\int}_{#1}}{\\mathop{\\int\\!\\!\\!\\int\\!\\!\\!\\int}_{#1}}{\\mathop{\\int\\!\\!\\!\\int\\!\\!\\!\\int}_{#1}}}",1]
   }
},
  "HTML-CSS": { scale: 100},
  menuSettings: { zscale: "150%", zoom: "Double-Click" }
});
    JXG.Options.text.display = 'html';
    JXG.Options.text.useMathJax = true;
</script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/math
jax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<script>
MathJax.Hub.Register.StartupHook("End",function () {
  if(typeof window.orientation === 'undefined'){
    var i,x;
    x = document.getElementsByClassName("webgl_display");
    for (i=0; i<x.length; i++) {
      x[i].style.display = "block";
    }
    x = document.getElementsByClassName("no_webgl_display");
    for (i=0; i<x.length; i++) {
      x[i].style.display = "none";
    }
  }
});
</script>

<script src="js/jquery-3.1.0.min.js"></script>
<script src="https://sagecell.sagemath.org/static/embedded_sagecell.js"></script>
<script src="js/jquery.visible.min.js"></script>
<script type="text/javascript" src="js/knowl.js"></script>
<style type="text/css">

.sagecell .CodeMirror {
  height: auto;
}

.sagecell .CodeMirror-scroll {
  overflow-y: hidden;
  overflow-x: auto;
}

.sagecell-practice .CodeMirror-scroll {
}

.sagecell button.sagecell_evalButton {
    font-size: 50%;
}

.sagecell_sessionContainer {
    margin-bottom:1em;
}
</style>
<script>
function toggle(a) {
  var b = String(a);
  b=b.replace("contents","button");
  if (document.getElementById(a).style.display == "block") {
    document.getElementById(a).style.display = "none";
    document.getElementById(b).src = "expand_submenu.png";
  } else {
    document.getElementById(a).style.display = "block";
    document.getElementById(b).src = "collapse_submenu.png";
  }
}
function toggle_sidebar() {
  if (document.getElementById('sidebar').style.display == "block") {
    document.getElementById('sidebar').style.display = "none";
    document.getElementById('menu_expand').style.display = "block";
  } else {
    document.getElementById('sidebar').style.display = "block";
    document.getElementById('menu_expand').style.display = "none";
  }
}
</script>

</head>

<body class="" onload="toggle('chapter_16_contents')">
<div id="header">
<div class="right">
<div class="bread">
  <a href=".">Home</a> &raquo; <a href="chapter16.html">Vector Calculus</a> &raquo; <a href="section16.07.html">Surface Integrals</a>
</div>

<FORM method=GET action=https://www.google.com/custom id="search">
<INPUT TYPE=text name=q size=31 maxlength=255 value="" style="font-size:small">
<INPUT type=submit name=sa VALUE="Search the book" style="font-size:small">
<INPUT type=hidden name=cof VALUE="AH:center;AWFID:198dc2b883340b1f;">
<input type=hidden name=domains value="www.whitman.edu">
<input type=hidden name=sitesearch value="www.whitman.edu/mathematics/calculus_online/">
</FORM>
<div id="title"><span id="title-content">16.7 Surface Integrals</span></div><a href="#exercises">[Jump to exercises]</a>
</div>
</div>
<div id="menu_expand" style="display:none"><a href="javascript:toggle_sidebar()">Expand menu</a></div>
<div id="sidebar" style="display:block">
<h2 id="menu_collapse"><a href='javascript:toggle_sidebar()'>Collapse menu</a></h2>
<h2 class="link"><img id="chapter_01_button" src="expand_submenu.png" onclick='toggle("chapter_01_contents")'><a href="chapter01.html">1 Analytic Geometry</a></h2>

<ul class="list" id="chapter_01_contents">
<li><a href="section01.01.html">1. Lines</a></li>
<li><a href="section01.02.html">2. Distance Between Two Points; Circles</a></li>
<li><a href="section01.03.html">3. Functions</a></li>
<li><a href="section01.04.html">4. Shifts and Dilations</a></li>
</ul>

<h2 class="link"><img id="chapter_02_button" src="expand_submenu.png" onclick='toggle("chapter_02_contents")'><a href="chapter02.html">2 Instantaneous Rate of Change:  The Derivative</a></h2>

<ul class="list" id="chapter_02_contents">
<li><a href="section02.01.html">1. The slope of a function</a></li>
<li><a href="section02.02.html">2. An example</a></li>
<li><a href="section02.03.html">3. Limits</a></li>
<li><a href="section02.04.html">4. The Derivative Function</a></li>
<li><a href="section02.05.html">5. Adjectives For Functions</a></li>
</ul>

<h2 class="link"><img id="chapter_03_button" src="expand_submenu.png" onclick='toggle("chapter_03_contents")'><a href="chapter03.html">3 Rules for Finding Derivatives</a></h2>

<ul class="list" id="chapter_03_contents">
<li><a href="section03.01.html">1. The Power Rule</a></li>
<li><a href="section03.02.html">2. Linearity of the Derivative</a></li>
<li><a href="section03.03.html">3. The Product Rule</a></li>
<li><a href="section03.04.html">4. The Quotient Rule</a></li>
<li><a href="section03.05.html">5. The Chain Rule</a></li>
</ul>

<h2 class="link"><img id="chapter_04_button" src="expand_submenu.png" onclick='toggle("chapter_04_contents")'><a href="chapter04.html">4 Transcendental Functions</a></h2>

<ul class="list" id="chapter_04_contents">
<li><a href="section04.01.html">1. Trigonometric Functions</a></li>
<li><a href="section04.02.html">2. The Derivative of $\sin x$</a></li>
<li><a href="section04.03.html">3. A hard limit</a></li>
<li><a href="section04.04.html">4. The Derivative of $\sin x$, continued</a></li>
<li><a href="section04.05.html">5. Derivatives of the Trigonometric Functions</a></li>
<li><a href="section04.06.html">6. Exponential and Logarithmic functions</a></li>
<li><a href="section04.07.html">7. Derivatives of the exponential and  logarithmic functions</a></li>
<li><a href="section04.08.html">8. Implicit Differentiation</a></li>
<li><a href="section04.09.html">9. Inverse Trigonometric Functions</a></li>
<li><a href="section04.10.html">10. Limits revisited</a></li>
<li><a href="section04.11.html">11. Hyperbolic Functions</a></li>
</ul>

<h2 class="link"><img id="chapter_05_button" src="expand_submenu.png" onclick='toggle("chapter_05_contents")'><a href="chapter05.html">5 Curve Sketching</a></h2>

<ul class="list" id="chapter_05_contents">
<li><a href="section05.01.html">1. Maxima and Minima</a></li>
<li><a href="section05.02.html">2. The first derivative test</a></li>
<li><a href="section05.03.html">3. The second derivative test</a></li>
<li><a href="section05.04.html">4. Concavity and inflection points</a></li>
<li><a href="section05.05.html">5. Asymptotes and Other Things to Look For</a></li>
</ul>

<h2 class="link"><img id="chapter_06_button" src="expand_submenu.png" onclick='toggle("chapter_06_contents")'><a href="chapter06.html">6 Applications of the Derivative</a></h2>

<ul class="list" id="chapter_06_contents">
<li><a href="section06.01.html">1. Optimization</a></li>
<li><a href="section06.02.html">2. Related Rates</a></li>
<li><a href="section06.03.html">3. Newton's Method</a></li>
<li><a href="section06.04.html">4. Linear Approximations</a></li>
<li><a href="section06.05.html">5. The Mean Value Theorem</a></li>
</ul>

<h2 class="link"><img id="chapter_07_button" src="expand_submenu.png" onclick='toggle("chapter_07_contents")'><a href="chapter07.html">7 Integration</a></h2>

<ul class="list" id="chapter_07_contents">
<li><a href="section07.01.html">1. Two examples</a></li>
<li><a href="section07.02.html">2. The Fundamental Theorem of Calculus</a></li>
<li><a href="section07.03.html">3. Some Properties of Integrals</a></li>
</ul>

<h2 class="link"><img id="chapter_08_button" src="expand_submenu.png" onclick='toggle("chapter_08_contents")'><a href="chapter08.html">8 Techniques of Integration</a></h2>

<ul class="list" id="chapter_08_contents">
<li><a href="section08.01.html">1. Substitution</a></li>
<li><a href="section08.02.html">2. Powers of sine and cosine</a></li>
<li><a href="section08.03.html">3. Trigonometric Substitutions</a></li>
<li><a href="section08.04.html">4. Integration by Parts</a></li>
<li><a href="section08.05.html">5. Rational Functions</a></li>
<li><a href="section08.06.html">6. Numerical Integration</a></li>
<li><a href="section08.07.html">7. Additional exercises</a></li>
</ul>

<h2 class="link"><img id="chapter_09_button" src="expand_submenu.png" onclick='toggle("chapter_09_contents")'><a href="chapter09.html">9 Applications of Integration</a></h2>

<ul class="list" id="chapter_09_contents">
<li><a href="section09.01.html">1. Area between curves</a></li>
<li><a href="section09.02.html">2. Distance, Velocity, Acceleration</a></li>
<li><a href="section09.03.html">3. Volume</a></li>
<li><a href="section09.04.html">4. Average value of a function</a></li>
<li><a href="section09.05.html">5. Work</a></li>
<li><a href="section09.06.html">6. Center of Mass</a></li>
<li><a href="section09.07.html">7. Kinetic energy; improper integrals</a></li>
<li><a href="section09.08.html">8. Probability</a></li>
<li><a href="section09.09.html">9. Arc Length</a></li>
<li><a href="section09.10.html">10. Surface Area</a></li>
</ul>

<h2 class="link"><img id="chapter_10_button" src="expand_submenu.png" onclick='toggle("chapter_10_contents")'><a href="chapter10.html">10 Polar Coordinates,  Parametric Equations</a></h2>

<ul class="list" id="chapter_10_contents">
<li><a href="section10.01.html">1. Polar Coordinates</a></li>
<li><a href="section10.02.html">2. Slopes in polar coordinates</a></li>
<li><a href="section10.03.html">3. Areas in polar coordinates</a></li>
<li><a href="section10.04.html">4. Parametric Equations</a></li>
<li><a href="section10.05.html">5. Calculus with Parametric Equations</a></li>
</ul>

<h2 class="link"><img id="chapter_11_button" src="expand_submenu.png" onclick='toggle("chapter_11_contents")'><a href="chapter11.html">11 Sequences and Series</a></h2>

<ul class="list" id="chapter_11_contents">
<li><a href="section11.01.html">1. Sequences</a></li>
<li><a href="section11.02.html">2. Series</a></li>
<li><a href="section11.03.html">3. The Integral Test</a></li>
<li><a href="section11.04.html">4. Alternating Series</a></li>
<li><a href="section11.05.html">5. Comparison Tests</a></li>
<li><a href="section11.06.html">6. Absolute Convergence</a></li>
<li><a href="section11.07.html">7. The Ratio and Root Tests</a></li>
<li><a href="section11.08.html">8. Power Series</a></li>
<li><a href="section11.09.html">9. Calculus with Power Series</a></li>
<li><a href="section11.10.html">10. Taylor Series</a></li>
<li><a href="section11.11.html">11. Taylor's Theorem</a></li>
<li><a href="section11.12.html">12. Additional exercises</a></li>
</ul>

<h2 class="link"><img id="chapter_12_button" src="expand_submenu.png" onclick='toggle("chapter_12_contents")'><a href="chapter12.html">12 Three Dimensions</a></h2>

<ul class="list" id="chapter_12_contents">
<li><a href="section12.01.html">1. The Coordinate System</a></li>
<li><a href="section12.02.html">2. Vectors</a></li>
<li><a href="section12.03.html">3. The Dot Product</a></li>
<li><a href="section12.04.html">4. The Cross Product</a></li>
<li><a href="section12.05.html">5. Lines and Planes</a></li>
<li><a href="section12.06.html">6. Other Coordinate Systems</a></li>
</ul>

<h2 class="link"><img id="chapter_13_button" src="expand_submenu.png" onclick='toggle("chapter_13_contents")'><a href="chapter13.html">13 Vector Functions</a></h2>

<ul class="list" id="chapter_13_contents">
<li><a href="section13.01.html">1. Space Curves</a></li>
<li><a href="section13.02.html">2. Calculus with vector functions</a></li>
<li><a href="section13.03.html">3. Arc length and curvature</a></li>
<li><a href="section13.04.html">4. Motion along a curve</a></li>
</ul>

<h2 class="link"><img id="chapter_14_button" src="expand_submenu.png" onclick='toggle("chapter_14_contents")'><a href="chapter14.html">14 Partial Differentiation</a></h2>

<ul class="list" id="chapter_14_contents">
<li><a href="section14.01.html">1. Functions of Several Variables</a></li>
<li><a href="section14.02.html">2. Limits and Continuity</a></li>
<li><a href="section14.03.html">3. Partial Differentiation</a></li>
<li><a href="section14.04.html">4. The Chain Rule</a></li>
<li><a href="section14.05.html">5. Directional Derivatives</a></li>
<li><a href="section14.06.html">6. Higher order derivatives</a></li>
<li><a href="section14.07.html">7. Maxima and minima</a></li>
<li><a href="section14.08.html">8. Lagrange Multipliers</a></li>
</ul>

<h2 class="link"><img id="chapter_15_button" src="expand_submenu.png" onclick='toggle("chapter_15_contents")'><a href="chapter15.html">15 Multiple Integration</a></h2>

<ul class="list" id="chapter_15_contents">
<li><a href="section15.01.html">1. Volume and Average Height</a></li>
<li><a href="section15.02.html">2. Double Integrals in Cylindrical Coordinates</a></li>
<li><a href="section15.03.html">3. Moment and Center of Mass</a></li>
<li><a href="section15.04.html">4. Surface Area</a></li>
<li><a href="section15.05.html">5. Triple Integrals</a></li>
<li><a href="section15.06.html">6. Cylindrical and Spherical Coordinates</a></li>
<li><a href="section15.07.html">7. Change of Variables</a></li>
</ul>

<h2 class="link"><img id="chapter_16_button" src="expand_submenu.png" onclick='toggle("chapter_16_contents")'><a href="chapter16.html">16 Vector Calculus</a></h2>

<ul class="list" id="chapter_16_contents">
<li><a href="section16.01.html">1. Vector Fields</a></li>
<li><a href="section16.02.html">2. Line Integrals</a></li>
<li><a href="section16.03.html">3. The Fundamental Theorem of Line Integrals</a></li>
<li><a href="section16.04.html">4. Green's Theorem</a></li>
<li><a href="section16.05.html">5. Divergence and Curl</a></li>
<li><a href="section16.06.html">6. Vector Functions for Surfaces</a></li>
<li><a href="section16.07.html">7. Surface Integrals</a></li>
<li><a href="section16.08.html">8. Stokes's Theorem</a></li>
<li><a href="section16.09.html">9. The Divergence Theorem</a></li>
</ul>

<h2 class="link"><img id="chapter_17_button" src="expand_submenu.png" onclick='toggle("chapter_17_contents")'><a href="chapter17.html">17 Differential Equations</a></h2>

<ul class="list" id="chapter_17_contents">
<li><a href="section17.01.html">1. First Order Differential Equations</a></li>
<li><a href="section17.02.html">2. First Order Homogeneous Linear Equations</a></li>
<li><a href="section17.03.html">3. First Order Linear Equations</a></li>
<li><a href="section17.04.html">4. Approximation</a></li>
<li><a href="section17.05.html">5. Second Order Homogeneous Equations</a></li>
<li><a href="section17.06.html">6. Second Order Linear Equations</a></li>
<li><a href="section17.07.html">7. Second Order Linear Equations, take two</a></li>
</ul>

<h2 class="link"><img id="chapter_18_button" src="expand_submenu.png" onclick='toggle("chapter_18_contents")'><a href="chapter18.html">18 Useful formulas</a></h2>

<ul class="list" id="chapter_18_contents">
</ul>

</div>

<div id="main">

<div id="next"><a href="section16.06.html"><img src=previous_section.png width="30"></a>&nbsp;&nbsp;<a href="section16.08.html"><img src=next_section.png width="30"></a></div>

<div id="content">
<p>


</p><p>
In the integral for surface area,
$$\int_a^b\int_c^d |{\bf r}_u\times{\bf r}_v|\,du\,dv,$$
the integrand $|{\bf r}_u\times{\bf r}_v|\,du\,dv$
is the area of a tiny parallelogram, that is, a very small surface
area, so it is reasonable to abbreviate it $dS$; then a shortened
version of the integral is
$$\dint{D} 1\cdot dS.$$
We have already seen that if $D$ is a region in the plane, the area of
$D$ may be computed with 
$$\dint{D} 1\cdot dA,$$
so this is really quite familiar, but the $dS$ hides a little more
detail than does $dA$.
</p><p>
Just as we can integrate functions $f(x,y)$ over regions in the plane,
using
$$\dint{D} f(x,y)\, dA,$$
so we can compute integrals over surfaces in space, using
$$\dint{D} f(x,y,z)\, dS.$$
In practice this means that we have a vector function
${\bf r}(u,v)=\langle x(u,v),y(u,v),z(u,v)\rangle$ for the surface,
and the integral we compute is
$$\int_a^b\int_c^d f(x(u,v),y(u,v),z(u,v))|{\bf r}_u\times{\bf
  r}_v|\,du\,dv.$$ 
That is, we express everything in terms of $u$ and $v$, and then we
can do an ordinary double integral.
</p><p>
</p>
<div class="example">
<p>
<span class="theoremlabel">Example 16.7.1 </span>Suppose a thin object occupies the upper hemisphere of 
$x^2+y^2+z^2=1$ and has density $\sigma(x,y,z)=z$. Find the mass 
and center of mass of the
object. (Note that the object is just a thin shell; it does not occupy
the interior of the hemisphere.)
</p><p>
We write the hemisphere as ${\bf r}(\phi,\theta)=
\langle \cos\theta\sin\phi, \sin\theta\sin\phi, \cos\phi\rangle$,
$0\le\phi\le \pi/2$ and $0\le\theta\le 2\pi$. So
${\bf r}_\theta = \langle -\sin\theta\sin\phi, \cos\theta\sin\phi, 0\rangle$
and 
${\bf r}_\phi =\langle \cos\theta\cos\phi, \sin\theta\cos\phi, -\sin\phi\rangle$.
Then
$${\bf r}_\theta\times{\bf r}_\phi =
\langle -\cos\theta\sin^2\phi,-\sin\theta\sin^2\phi,-\cos\phi\sin\phi\rangle$$
and
$$ |{\bf r}_\theta\times{\bf r}_\phi| = |\sin\phi| = \sin\phi,$$
since we are interested only in $0\le\phi\le \pi/2$.
Finally, the density is $z=\cos\phi$ and the integral for mass is
$$\int_0^{2\pi}\int_0^{\pi/2} \cos\phi\sin\phi\,d\phi\,d\theta=\pi.$$
</p><p>
By symmetry, the center of mass is clearly on the $z$-axis, so we only
need to find the $z$-coordinate of the center of mass. The moment
around the $x$-$y$ plane is
$$\int_0^{2\pi}\int_0^{\pi/2} z\cos\phi\sin\phi\,d\phi\,d\theta
=\int_0^{2\pi}\int_0^{\pi/2} \cos^2\phi\sin\phi\,d\phi\,d\theta
={2\pi\over 3},$$
so the center of mass is at $(0,0,2/3)$.

</p>
</div><!-- example -->
<p>
</p><p>
Now suppose that ${\bf F}$ is a vector field; imagine that it
represents the velocity of some fluid at each point in space. We would
like to measure how much fluid is passing through a surface $D$, the
<b>flux</b> across $D$. As usual, we imagine computing
the flux across a very small section of the surface, with area $dS$,
and then adding up all such small fluxes over $D$ with an
integral. Suppose that vector $\bf N$ is a unit normal to the surface
at a point; ${\bf F}\cdot{\bf N}$ is the scalar projection of $\bf F$
onto the direction of $\bf N$, so it measures how fast the fluid is
moving across the surface. In one unit of time the fluid moving across
the surface will fill a volume of ${\bf F}\cdot{\bf N}\,dS$, which is
therefore the rate at which the fluid is moving across a small patch
of the surface. Thus, the total flux across $D$ is
$$\dint{D} {\bf F}\cdot{\bf N}\,dS=\dint{D} {\bf F}\cdot\,d{\bf S},$$
defining $d{\bf S}={\bf N}\,dS$.
As usual, certain conditions must be met for this to work out; chief
among them is the nature of the surface. As we integrate over the
surface, we must choose the normal vectors $\bf N$ in such a way that
they point "the same way'' through the surface. For example, if the
surface is roughly horizontal in orientation, we might want to measure
the flux in the "upwards'' direction, or if the surface is closed,
like a sphere, we might want to measure the flux "outwards'' across
the surface. In the first case we would choose $\bf N$ to have
positive $z$ component, in the second we would make sure that $\bf N$
points away from the origin. Unfortunately, there are surfaces that
are not <b>orientable</b>: they have
only one side, so that it is not possible to choose the normal vectors
to point in the "same way'' through the surface. The most famous such
surface is the M&ouml;bius strip shown in figure <a href="section16.07.html#fig:moebius">16.7.1</a>. It
is quite easy to make such a strip with a piece of paper and some
tape. If you have never done this, it is quite instructive; in
particular, you should draw a line down the center of the strip until
you return to your starting point. No matter how unit normal vectors
are assigned to the points of the M&ouml;bius strip, there will be normal
vectors very close to each other pointing in opposite directions.
</p><p>
<a id="fig:moebius"></a>
</p><div class='figure'><!-- Vector_calculus-mobius_strip.html -->
<!-- Figure 16.7.1 -->

<table class="webgl_display" style="display:none;margin-left:auto;margin-right:auto">
<tr>
<td id="moebius" style='text-align:center'></td>
<td id="moebius_with_normals" style='text-align:center'></td>
</tr>
</table>
<div class="no_webgl_display" style="display:block;text-align:center">
<a href="http://www.whitman.edu/mathematics/calculus_applets/moebius">
<img src="images/moebius.png" style="width:400px"></a>
</div>
<script>
    MathJax.Hub.Register.StartupHook("End",function(){    
	var xoffset = 0; yoffset = 0; zoffset = 0;
	var SCREEN_WIDTH = 400, SCREEN_HEIGHT = 400;
	var container, scene, camera, renderer, controls;
	var keyboard = new THREEx.KeyboardState();
	var clock = new THREE.Clock();
	var meshFunction;
	var usegments = 40, vsegments=10;
	
	var xMin = xMax = yMin = yMax = 0; // for autosizing window
	
	var graphGeometry;
	
	if(typeof window.orientation === 'undefined') {
	    init();
	    animate();
	}

	function init() 
	{
	    scene = new THREE.Scene();
	    if ( Detector.webgl )
		renderer = new THREE.WebGLRenderer( {alpha:true, antialias:true} );
	    else
		renderer = new THREE.CanvasRenderer(); 
	    renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
	    container = document.getElementById( 'moebius' );
	    container.appendChild( renderer.domElement );
	    var light = new THREE.PointLight(0xffffff,1,100);
	    light.position.set(3,0,10);
	    scene.add(light);
	    var light_amb = new THREE.AmbientLight( 0xaaaaaa ); // soft white light
	    scene.add( light_amb );
	    
	    // Background clear color
	    // renderer.setClearColorHex( 0xffffff, 0 );
	    
	    plot_it_0();
//	    plot_axes();
	    resetCamera();
	}
	
	
	function resetCamera()
	{
	    var VIEW_ANGLE = 13, ASPECT = SCREEN_WIDTH / SCREEN_HEIGHT, NEAR = 0.1, FAR = 20000;
	    // Orthog camera
	    //      var zoom = 3;
	    //      camera = new THREE.OrthographicCamera( -zoom*ASPECT,zoom*ASPECT,zoom,-zoom, NEAR, FAR);
	    //      camera.position.x = zoom*2;
	    //      camera.position.y = zoom*1.5;
	    //      camera.position.z = zoom*1.5;
	    // Perspective camera
	    camera = new THREE.PerspectiveCamera( VIEW_ANGLE, ASPECT, NEAR, FAR);
	    scene.add(camera);
	    camera.position.set(20,10,15);
	    camera.lookAt(scene.position);  
	    
	    camera.up.set( 0, 0, 1 ); 
	    scene.add(camera);
	    
	    controls = new THREE.TrackballControls( camera, renderer.domElement );
	    controls.rotateSpeed = 1;
	    THREEx.WindowResize(renderer, camera);
	}
	
	function animate() 
	{
	    requestAnimationFrame( animate );
	    if ($('#moebius').visible(true) && active ) {
		render();
		update();
	    }
	}

	function update()
	{
	    if ( keyboard.pressed("z") ) 
	    { 
		// do something
	    }
	    
	    controls.update();
	    //	stats.update();
	}
	
	function render() 
	{
	    renderer.render( scene, camera );
	}
	
	
	function plot_it_0()
	{
	    var loader = new THREE.TextureLoader();
	    var gridTexture = loader.load( 'images/square.png');
	    gridTexture.wrapS = gridTexture.wrapT = THREE.RepeatWrapping;
	    gridTexture.repeat.set( 6,50 );
	    var gridMaterial = new THREE.MeshLambertMaterial( {map:gridTexture, vertexColors: THREE.VertexColors,side:THREE.DoubleSide } );
	    var useg = 10,vseg = 100;
	    function x(r,t) {
		return 2*Math.cos(t)+r*Math.cos(t/2)+xoffset;
	    }
	    function y(r,t) {
		return 2*Math.sin(t)+r*Math.cos(t/2)+yoffset;
	    }
	    function z(r,t) {
		return r*Math.sin(t/2)+zoffset;
	    }
	    createGraph(x,y,z,-0.5,0.5,0,2*Math.PI,useg,vseg,scene,gridMaterial,new THREE.Color( 0xffffff ),false,false);
	}
	
	function plot_axes()
	{
	    var spritex = makeTextSprite( "x", { fontsize: 55, borderColor: {r:0, g:0, b:255, a:1.0}, xoffset:-25, yoffset:25 } );
	    spritex.position.set(2.2+xoffset,yoffset,0+zoffset);
	    scene.add( spritex );
	    var spritey = makeTextSprite( "y", { fontsize: 55, borderColor: {r:0, g:0, b:255, a:1.0},xoffset:0 } );
	    spritey.position.set(xoffset,3.5+yoffset,zoffset);
	    scene.add( spritey );
	    var spritez = makeTextSprite( "z", { fontsize: 55, borderColor: {r:0, g:0, b:255, a:1.0}, yoffset:-10 } );
	    spritez.position.set(xoffset,yoffset,5+zoffset);
	    scene.add( spritez );
	    
	    var axes = buildAxes();
	    scene.add(axes);
	}

	function createGraph(xFunc,yFunc,zFunc,uMin,uMax,vMin,vMax,useg,vseg,sc,material,clr,solid,box)
	{
	    var graphMesh;
	    uRange = uMax - uMin;
	    vRange = vMax - vMin;
	    meshFunction = function(u0, v0) 
	    {
		var u = uRange * u0 + uMin;
		var v = vRange * v0 + vMin;
		var x = xFunc(u,v);
		var y = yFunc(u,v);
		var z = zFunc(u,v);
		if ( isNaN(x) || isNaN(y) || isNaN(z) )
		    return new THREE.Vector3(0,0,0); // TODO: better fix
		else
		    return new THREE.Vector3(x, y, z);
	    };
	    
	    // true => sensible image tile repeat...
	    graphGeometry = new THREE.ParametricGeometry( meshFunction, useg, vseg, true );
	    ///////////////////////////////////////////////
	    // calculate vertex colors based on Z values //
	    ///////////////////////////////////////////////
	    graphGeometry.computeBoundingBox();
	    zMin = graphGeometry.boundingBox.min.z;
	    zMax = graphGeometry.boundingBox.max.z;
	    zRange = zMax - zMin;
	    var defaultcolor = new THREE.Color( 0xff0000 );
	    var color, point, face, numberOfSides, vertexIndex;
	    // faces are indexed using characters
	    var faceIndices = [ 'a', 'b', 'c', 'd' ];
	    // first, assign colors to vertices as desired
	    if (!solid) {
		for ( var i = 0; i < graphGeometry.vertices.length; i++ ) 
		{
		    point = graphGeometry.vertices[ i ];
		    color = new THREE.Color( 0x0000ff );
		    //	  color.setHSL( 0.7 *(10-point.x)/10 , 1, 0.1+0.3*(10 - point.z) / 10 );
		    color.setHSL( 0.2+0.8*(zMax - (point.z)/zRange), 0.6, 0.5 );
		    graphGeometry.colors[i] = color; // use this array for convenience
		}
	    }
	    // copy the colors as necessary to the face's vertexColors array.
	    for ( var i = 0; i < graphGeometry.faces.length; i++ ) 
	    {
		face = graphGeometry.faces[ i ];
		numberOfSides = ( face instanceof THREE.Face3 ) ? 3 : 4;
		for( var j = 0; j < numberOfSides; j++ ) 
		{
		    if (solid) {
			face.vertexColors[ j ] = clr;
		    } else {
			vertexIndex = face[ faceIndices[ j ] ];
			face.vertexColors[ j ] = graphGeometry.colors[vertexIndex ];
			//	      face.vertexColors[ j ] = clr;
		    }
		}
	    }
	    ///////////////////////
	    // end vertex colors //
	    ///////////////////////
	    
	    
	    xMin = graphGeometry.boundingBox.min.x;
	    xMax = graphGeometry.boundingBox.max.x;
	    yMin = graphGeometry.boundingBox.min.y;
	    yMax = graphGeometry.boundingBox.max.y;
	    
	    if (graphMesh) 
	    {
		sc.remove( graphMesh );
		// renderer.deallocateObject( graphMesh );
	    }
	    
	    graphMesh = new THREE.Mesh( graphGeometry,material );
	    
	    graphMesh.doubleSided = true;
	    sc.add(graphMesh);
	    if (box) {
		var bbox = new THREE.BoundingBoxHelper( graphMesh, 0x000000 );
		bbox.update();
		scene.add( bbox );	
	    }
	}

	function buildAxes() {
	    var axes = new THREE.Object3D();
	    
	    axes.add( buildAxis( new THREE.Vector3( xoffset, yoffset, zoffset ), new THREE.Vector3( 2.2+xoffset, yoffset, zoffset ), 0x000000, false ) ); // +X
//	    axes.add( buildAxis( new THREE.Vector3( xoffset, yoffset, zoffset ), new THREE.Vector3( -5+xoffset, yoffset, zoffset ), 0x000000, true) ); // -X
	    axes.add( buildAxis( new THREE.Vector3( xoffset, yoffset, zoffset ), new THREE.Vector3( xoffset, 3.5+yoffset, zoffset ), 0x000000, false ) ); // +Y
//	    axes.add( buildAxis( new THREE.Vector3( xoffset, yoffset, zoffset ), new THREE.Vector3( xoffset, -5+yoffset, zoffset ), 0x000000, true ) ); // -Y
	    axes.add( buildAxis( new THREE.Vector3( xoffset, yoffset, zoffset ), new THREE.Vector3( xoffset, yoffset, 5+zoffset ), 0x000000, false ) ); // +Z
//	    axes.add( buildAxis( new THREE.Vector3( xoffset, yoffset, zoffset ), new THREE.Vector3( xoffset, yoffset, -5+zoffset ), 0x000000, true ) ); // -Z
	    return axes;
	}	
	
	function buildAxis( src, dst, colorHex, dashed ) {
	    var geom = new THREE.Geometry();
	    var mat;
	    
	    if(dashed) {
		mat = new THREE.LineDashedMaterial({ linewidth: 1, color: colorHex, dashSize: 0.05, gapSize: 0.05 });
	    } else {
		mat = new THREE.LineBasicMaterial({ linewidth: 1, color: colorHex });
	    }
	    
	    geom.vertices.push( src.clone() );
	    geom.vertices.push( dst.clone() );
	    geom.computeLineDistances();
	    
	    var axis = new THREE.Line( geom, mat );
	    
	    return axis;
	}

	function makeTextSprite(message, opts) {
	    var parameters = opts || {};
	    var fontface = parameters.fontface || 'Helvetiker';
	    var fontsize = parameters.fontsize || 70;
	    var borderThickness = parameters.borderThickness || 1;
	    var xoffset = parameters.xoffset || 0;
	    var yoffset = parameters.yoffset || 0;
	    var canvas = document.createElement('canvas');
	    canvas.width = canvas.height = 200;
	    var context = canvas.getContext('2d');
	    context.font = fontsize + "px " + fontface;

  // get size data (height depends only on font size)
	    var metrics = context.measureText(message);
	    var textWidth = metrics.width;
	    
  // text color
	    context.fillStyle = 'rgba(0, 0, 0, 1.0)';
	    context.fillText(message, canvas.width/2+xoffset, canvas.width/2+yoffset);
//	    alert(canvas.width);
  // canvas contents will be used for a texture
	    var texture = new THREE.Texture(canvas)
	    texture.minFilter = THREE.LinearFilter;
	    texture.needsUpdate = true;
	    //roundRect(context, borderThickness, borderThickness, textWidth + 2 * borderThickness, fontsize * 1.4 + 2* borderThickness, 6);
	    var spriteMaterial = new THREE.SpriteMaterial({
		map: texture
//              useScreenCoordinates: false
	    });
	    var sprite = new THREE.Sprite(spriteMaterial);
	    sprite.scale.set(1,1,1);
	    return sprite;
	}
    });


  MathJax.Hub.Register.StartupHook("End",function(){    
	var xoffset = 0; yoffset = 0; zoffset = 0;
	var SCREEN_WIDTH = 400, SCREEN_HEIGHT = 400;
	var container, scene, camera, renderer, controls;
	var keyboard = new THREEx.KeyboardState();
	var clock = new THREE.Clock();
	var meshFunction;
	var usegments = 40, vsegments=10;
	var nxtext="1/2*(4*cos(t)*sin(1/2*t) - r)/sqrt(-2*r*cos(t)*sin(1/2*t) + 1/2*r^2 + 2*(4*cos(1/2*t)^2*cos(t) + r*sin(1/2*t))*sin(t) + 4)";
	var nx = Parser.parse(nxtext).toJSFunction(['t','r']);
	
	var nytext="1/2*(4*sin(1/2*t)*sin(t) + r)/sqrt(-2*r*cos(t)*sin(1/2*t) + 1/2*r^2 + 2*(4*cos(1/2*t)^2*cos(t) + r*sin(1/2*t))*sin(t) + 4)";
	var ny = Parser.parse(nytext).toJSFunction(['t','r']);
	
	var nztext="-2*(cos(1/2*t)*cos(t) + cos(1/2*t)*sin(t))/sqrt(-2*r*cos(t)*sin(1/2*t) + 1/2*r^2 + 2*(4*cos(1/2*t)^2*cos(t) + r*sin(1/2*t))*sin(t) + 4)";
	var nz = Parser.parse(nztext).toJSFunction(['t','r']);
	
	var xMin = xMax = yMin = yMax = 0; // for autosizing window
	
	var graphGeometry;
	
      if(typeof window.orientation === 'undefined') {
	  init();
	  animate();
      }

	function init() 
	{
	    scene = new THREE.Scene();
	    if ( Detector.webgl )
		renderer = new THREE.WebGLRenderer( {alpha:true, antialias:true} );
	    else
		renderer = new THREE.CanvasRenderer(); 
	    renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
	    container = document.getElementById( 'moebius_with_normals' );
	    container.appendChild( renderer.domElement );
	    var light = new THREE.PointLight(0xffffff,1,100);
	    light.position.set(3,0,10);
	    scene.add(light);
	    var light_amb = new THREE.AmbientLight( 0xaaaaaa ); // soft white light
	    scene.add( light_amb );
	    
	    // Background clear color
	    // renderer.setClearColorHex( 0xffffff, 0 );
	    
	    plot_it_0();
	    plot_normals();
//	    plot_axes();
	    resetCamera();
	}
	
	
	function resetCamera()
	{
	    var VIEW_ANGLE = 13, ASPECT = SCREEN_WIDTH / SCREEN_HEIGHT, NEAR = 0.1, FAR = 20000;
	    // Orthog camera
	    //      var zoom = 3;
	    //      camera = new THREE.OrthographicCamera( -zoom*ASPECT,zoom*ASPECT,zoom,-zoom, NEAR, FAR);
	    //      camera.position.x = zoom*2;
	    //      camera.position.y = zoom*1.5;
	    //      camera.position.z = zoom*1.5;
	    // Perspective camera
	    camera = new THREE.PerspectiveCamera( VIEW_ANGLE, ASPECT, NEAR, FAR);
	    scene.add(camera);
	    camera.position.set(20,10,15);
	    camera.lookAt(scene.position);  
	    
	    camera.up.set( 0, 0, 1 ); 
	    scene.add(camera);
	    
	    controls = new THREE.TrackballControls( camera, renderer.domElement );
	    controls.rotateSpeed = 1;
	    THREEx.WindowResize(renderer, camera);
	}
	
      function animate() 
      {
	  requestAnimationFrame( animate );
	  if ($('#moebius_with_normals').visible(true) && active ) {
	      render();
	      update();
	  }
      }


	function update()
	{
	    if ( keyboard.pressed("z") ) 
	    { 
		// do something
	    }
	    
	    controls.update();
	    //	stats.update();
	}
	
	function render() 
	{
	    renderer.render( scene, camera );
	}
	
	
	function plot_it_0()
	{
	    var loader = new THREE.TextureLoader();
	    var gridTexture = loader.load( 'images/square.png');
	    gridTexture.wrapS = gridTexture.wrapT = THREE.RepeatWrapping;
	    gridTexture.repeat.set( 6,50 );
	    var gridMaterial = new THREE.MeshLambertMaterial( {map:gridTexture, vertexColors: THREE.VertexColors,side:THREE.DoubleSide } );
	    var useg = 10,vseg = 100;
	    function x(r,t) {
		return 2*Math.cos(t)+r*Math.cos(t/2)+xoffset;
	    }
	    function y(r,t) {
		return 2*Math.sin(t)+r*Math.cos(t/2)+yoffset;
	    }
	    function z(r,t) {
		return r*Math.sin(t/2)+zoffset;
	    }
	    createGraph(x,y,z,-0.5,0.5,0,2*Math.PI,useg,vseg,scene,gridMaterial,new THREE.Color( 0xffffff ),false,false);
	}
	
	function plot_normals() {
	    function rx(t,r) {
		return 2*Math.cos(t)+r*Math.cos(t/2);
	    }
	    function ry(t,r) {
		return 2*Math.sin(t)+r*Math.cos(t/2);
	    }
	    function rz(t,r) {
		return  r*Math.sin(t/2);
	    }
	    for (i=0; i<=20; i++) {
		var x=i*2*Math.PI/20;
		var origin = new THREE.Vector3(rx(x,0.25),ry(x,0.25),rz(x,0.25));
		var dir = new THREE.Vector3(nx(x,0.25),ny(x,0.25),nz(x,0.25));
		var length = 1;
		var color = 0xff0000;
		var arrowHelper = new THREE.ArrowHelper( dir.normalize(), origin, length, color, 0.15, 0.08);
		scene.add( arrowHelper );
	    }
	}

	function plot_axes()
	{
	    var spritex = makeTextSprite( "x", { fontsize: 55, borderColor: {r:0, g:0, b:255, a:1.0}, xoffset:-25, yoffset:25 } );
	    spritex.position.set(2.2+xoffset,yoffset,0+zoffset);
	    scene.add( spritex );
	    var spritey = makeTextSprite( "y", { fontsize: 55, borderColor: {r:0, g:0, b:255, a:1.0},xoffset:0 } );
	    spritey.position.set(xoffset,3.5+yoffset,zoffset);
	    scene.add( spritey );
	    var spritez = makeTextSprite( "z", { fontsize: 55, borderColor: {r:0, g:0, b:255, a:1.0}, yoffset:-10 } );
	    spritez.position.set(xoffset,yoffset,5+zoffset);
	    scene.add( spritez );
	    
	    var axes = buildAxes();
	    scene.add(axes);
	}

	function createGraph(xFunc,yFunc,zFunc,uMin,uMax,vMin,vMax,useg,vseg,sc,material,clr,solid,box)
	{
	    var graphMesh;
	    uRange = uMax - uMin;
	    vRange = vMax - vMin;
	    meshFunction = function(u0, v0) 
	    {
		var u = uRange * u0 + uMin;
		var v = vRange * v0 + vMin;
		var x = xFunc(u,v);
		var y = yFunc(u,v);
		var z = zFunc(u,v);
		if ( isNaN(x) || isNaN(y) || isNaN(z) )
		    return new THREE.Vector3(0,0,0); // TODO: better fix
		else
		    return new THREE.Vector3(x, y, z);
	    };
	    
	    // true => sensible image tile repeat...
	    graphGeometry = new THREE.ParametricGeometry( meshFunction, useg, vseg, true );
	    ///////////////////////////////////////////////
	    // calculate vertex colors based on Z values //
	    ///////////////////////////////////////////////
	    graphGeometry.computeBoundingBox();
	    zMin = graphGeometry.boundingBox.min.z;
	    zMax = graphGeometry.boundingBox.max.z;
	    zRange = zMax - zMin;
	    var defaultcolor = new THREE.Color( 0xff0000 );
	    var color, point, face, numberOfSides, vertexIndex;
	    // faces are indexed using characters
	    var faceIndices = [ 'a', 'b', 'c', 'd' ];
	    // first, assign colors to vertices as desired
	    if (!solid) {
		for ( var i = 0; i < graphGeometry.vertices.length; i++ ) 
		{
		    point = graphGeometry.vertices[ i ];
		    color = new THREE.Color( 0x0000ff );
		    //	  color.setHSL( 0.7 *(10-point.x)/10 , 1, 0.1+0.3*(10 - point.z) / 10 );
		    color.setHSL( 0.2+0.8*(zMax - (point.z)/zRange), 0.6, 0.5 );
		    graphGeometry.colors[i] = color; // use this array for convenience
		}
	    }
	    // copy the colors as necessary to the face's vertexColors array.
	    for ( var i = 0; i < graphGeometry.faces.length; i++ ) 
	    {
		face = graphGeometry.faces[ i ];
		numberOfSides = ( face instanceof THREE.Face3 ) ? 3 : 4;
		for( var j = 0; j < numberOfSides; j++ ) 
		{
		    if (solid) {
			face.vertexColors[ j ] = clr;
		    } else {
			vertexIndex = face[ faceIndices[ j ] ];
			face.vertexColors[ j ] = graphGeometry.colors[vertexIndex ];
			//	      face.vertexColors[ j ] = clr;
		    }
		}
	    }
	    ///////////////////////
	    // end vertex colors //
	    ///////////////////////
	    
	    
	    xMin = graphGeometry.boundingBox.min.x;
	    xMax = graphGeometry.boundingBox.max.x;
	    yMin = graphGeometry.boundingBox.min.y;
	    yMax = graphGeometry.boundingBox.max.y;
	    
	    if (graphMesh) 
	    {
		sc.remove( graphMesh );
		// renderer.deallocateObject( graphMesh );
	    }
	    
	    graphMesh = new THREE.Mesh( graphGeometry,material );
	    
	    graphMesh.doubleSided = true;
	    sc.add(graphMesh);
	    if (box) {
		var bbox = new THREE.BoundingBoxHelper( graphMesh, 0x000000 );
		bbox.update();
		scene.add( bbox );	
	    }
	}

	function buildAxes() {
	    var axes = new THREE.Object3D();
	    
	    axes.add( buildAxis( new THREE.Vector3( xoffset, yoffset, zoffset ), new THREE.Vector3( 2.2+xoffset, yoffset, zoffset ), 0x000000, false ) ); // +X
//	    axes.add( buildAxis( new THREE.Vector3( xoffset, yoffset, zoffset ), new THREE.Vector3( -5+xoffset, yoffset, zoffset ), 0x000000, true) ); // -X
	    axes.add( buildAxis( new THREE.Vector3( xoffset, yoffset, zoffset ), new THREE.Vector3( xoffset, 3.5+yoffset, zoffset ), 0x000000, false ) ); // +Y
//	    axes.add( buildAxis( new THREE.Vector3( xoffset, yoffset, zoffset ), new THREE.Vector3( xoffset, -5+yoffset, zoffset ), 0x000000, true ) ); // -Y
	    axes.add( buildAxis( new THREE.Vector3( xoffset, yoffset, zoffset ), new THREE.Vector3( xoffset, yoffset, 5+zoffset ), 0x000000, false ) ); // +Z
//	    axes.add( buildAxis( new THREE.Vector3( xoffset, yoffset, zoffset ), new THREE.Vector3( xoffset, yoffset, -5+zoffset ), 0x000000, true ) ); // -Z
	    return axes;
	}	
	
	function buildAxis( src, dst, colorHex, dashed ) {
	    var geom = new THREE.Geometry();
	    var mat;
	    
	    if(dashed) {
		mat = new THREE.LineDashedMaterial({ linewidth: 1, color: colorHex, dashSize: 0.05, gapSize: 0.05 });
	    } else {
		mat = new THREE.LineBasicMaterial({ linewidth: 1, color: colorHex });
	    }
	    
	    geom.vertices.push( src.clone() );
	    geom.vertices.push( dst.clone() );
	    geom.computeLineDistances();
	    
	    var axis = new THREE.Line( geom, mat );
	    
	    return axis;
	}

	function makeTextSprite(message, opts) {
	    var parameters = opts || {};
	    var fontface = parameters.fontface || 'Helvetiker';
	    var fontsize = parameters.fontsize || 70;
	    var borderThickness = parameters.borderThickness || 1;
	    var xoffset = parameters.xoffset || 0;
	    var yoffset = parameters.yoffset || 0;
	    var canvas = document.createElement('canvas');
	    canvas.width = canvas.height = 200;
	    var context = canvas.getContext('2d');
	    context.font = fontsize + "px " + fontface;

  // get size data (height depends only on font size)
	    var metrics = context.measureText(message);
	    var textWidth = metrics.width;
	    
  // text color
	    context.fillStyle = 'rgba(0, 0, 0, 1.0)';
	    context.fillText(message, canvas.width/2+xoffset, canvas.width/2+yoffset);
//	    alert(canvas.width);
  // canvas contents will be used for a texture
	    var texture = new THREE.Texture(canvas)
	    texture.minFilter = THREE.LinearFilter;
	    texture.needsUpdate = true;
	    //roundRect(context, borderThickness, borderThickness, textWidth + 2 * borderThickness, fontsize * 1.4 + 2* borderThickness, 6);
	    var spriteMaterial = new THREE.SpriteMaterial({
		map: texture
//              useScreenCoordinates: false
	    });
	    var sprite = new THREE.Sprite(spriteMaterial);
	    sprite.scale.set(1,1,1);
	    return sprite;
	}
    });
</script>  
<div class='figcaption'><span class="figurenumber">Figure 16.7.1.</span> A M&ouml;bius strip.</div></div>
<p>
</p><p>
Assuming that the quantities involved are well behaved, however, the
flux of the vector field across the surface ${\bf r}(u,v)$ is
$$\dint{D} {\bf F}\cdot{\bf N}\,dS
=\dint{D}{\bf F}\cdot 
 {{\bf r}_u\times{\bf r}_v\over|{\bf r}_u\times{\bf r}_v|}
 |{\bf r}_u\times{\bf r}_v|\,dA
=\dint{D}{\bf F}\cdot ({\bf r}_u\times{\bf r}_v)\,dA.$$
In practice, we may have to use ${\bf r}_v\times{\bf r}_u$
or even something a bit more complicated to make sure that the normal
vector points in the desired direction.
</p><p>
</p>
<div class="example">
<p>
<span class="theoremlabel">Example 16.7.2 </span>Compute the flux of ${\bf F}=\langle x,y,z^4\rangle$ across the
cone $z=\sqrt{x^2+y^2}$, $0\le z\le 1$, in the downward direction.
</p><p>
We write the cone as a vector function: ${\bf r}=\langle v\cos u, v\sin u,
v\rangle$, $0\le u\le 2\pi$ and $0\le v\le 1$.
Then ${\bf r}_u=\langle -v\sin u, v\cos u,0\rangle$ and 
${\bf r}_v=\langle \cos u, \sin u, 1\rangle$ and
${\bf r}_u\times{\bf r}_v=\langle v\cos u,v\sin u,-v\rangle$.
The third coordinate $-v$ is negative, which is exactly what we
desire, that is, the normal vector points down through the
surface. Then 
$$\eqalign{
\int_0^{2\pi}\int_0^1 \langle x,y,z^4\rangle\cdot\langle v\cos
u,v\sin u,-v\rangle \,dv\,du
&=\int_0^{2\pi}\int_0^1 xv\cos u+yv\sin u-z^4v\,dv\,du\cr
&=\int_0^{2\pi}\int_0^1 v^2\cos^2 u+ v^2\sin^2 u-v^5\,dv\,du\cr
&=\int_0^{2\pi}\int_0^1 v^2-v^5\,dv\,du={\pi\over3}.\cr
}$$

</p>
</div><!-- example -->
<p>
</p><p>
</p>
<a id="exercises"></a><h2 class="exercises">Exercises 16.7</h2>
<p></p><p>
</p>
<p class="exercise"><b>Ex 16.7.1</b>
Find the center of mass of an object that occupies the upper
hemisphere of $x^2+y^2+z^2=1$ and has density $x^2+y^2$.
(<a knowl="" class="internal" value="$(0,0,3/8)$">answer</a>)


</p><p>
</p>
<p class="exercise"><b>Ex 16.7.2</b>
Find the center of mass of an object that occupies the
surface $z=xy$, $0\le x\le1$, $0\le y\le 1$ and has density $\sqrt{1+x^2+y^2}$.
(<a knowl="" class="internal" value="$(11/20,11/20,3/10)$">answer</a>)


</p><p>
</p>
<p class="exercise"><b>Ex 16.7.3</b>
Find the center of mass of an object that occupies the
surface $\ds z=\sqrt{x^2+y^2}$, $1\le z\le4$ and has density $x^2z$.
(<a knowl="" class="internal" value="$(0,0,2275/682)$">answer</a>)


</p><p>
</p>
<p class="exercise"><b>Ex 16.7.4</b>
Find the centroid of the surface of a right circular cone of
height $h$ and base radius $r$, not including the base.
(<a knowl="" class="internal" value="on center axis, $h/3$ above the base">answer</a>)


</p><p>
</p>
<p class="exercise"><b>Ex 16.7.5</b>
Evaluate $\ds \dint{D} \langle 2,-3,4\rangle\cdot {\bf
  N}\,dS$, where $D$ is given by $z=x^2+y^2$, $-1\le x\le 1$, $-1\le
y\le 1$, oriented up.
(<a knowl="" class="internal" value="$16$">answer</a>)


</p><p>
</p>
<p class="exercise"><b>Ex 16.7.6</b>
Evaluate $\ds \dint{D} \langle x,y,3\rangle\cdot {\bf
  N}\,dS$, where $D$ is given by $z=3x-5y$, $1\le x\le 2$, $0\le
y\le 2$, oriented up.
(<a knowl="" class="internal" value="$7$">answer</a>)


</p><p>
</p>
<p class="exercise"><b>Ex 16.7.7</b>
Evaluate $\ds \dint{D} \langle x,y,-2\rangle\cdot {\bf
  N}\,dS$, where $D$ is given by $z=1-x^2-y^2$, $x^2+y^2\le1$,
oriented up.
(<a knowl="" class="internal" value="$-\pi$">answer</a>)


</p><p>
</p>
<p class="exercise"><b>Ex 16.7.8</b>
Evaluate $\ds \dint{D} \langle xy, yz,zx\rangle\cdot {\bf
  N}\,dS$, where $D$ is given by $z=x+y^2+2$, $0\le x\le 1$, $x\le
y\le 1$, oriented up.
(<a knowl="" class="internal" value="$-137/120$">answer</a>)


</p><p>
</p>
<p class="exercise"><b>Ex 16.7.9</b>
Evaluate $\ds \dint{D} \langle e^x, e^y,z\rangle\cdot {\bf
  N}\,dS$, where $D$ is given by $z=xy$, $0\le x\le 1$, $-x\le
y\le x$, oriented up.
(<a knowl="" class="internal" value="$-2/e$">answer</a>)


</p><p>
</p>
<p class="exercise"><b>Ex 16.7.10</b>
Evaluate $\ds \dint{D} \langle xz,yz,z\rangle\cdot {\bf
N}\,dS$, where $D$ is given by $z=a^2-x^2-y^2$, $x^2+y^2\le b^2$, 
oriented up.
(<a knowl="" class="internal" value="$\pi b^2(-4b^4-3b^2+6a^2b^2+6a^2)/6$">answer</a>)


</p><p>
</p>
<p class="exercise"><b>Ex 16.7.11</b>
A fluid has density 870 kg/m$^3$ and flows with velocity ${\bf v} =
 \langle z,y^2,x^2\rangle$, where distances are in meters and the
 components of ${\bf v}$ are in meters per second.  Find the rate of flow
 outward through the portion of the cylinder $x^2+y^2 = 4$, $0\leq
 z\leq 1$ for which $y\ge 0$.
(<a knowl="" class="internal" value="$9280$ kg/s">answer</a>)


</p><p>
</p>
<p class="exercise"><b>Ex 16.7.12</b>
Gauss's Law says that the net charge, $Q$,
enclosed by a closed surface, $S$, is 
$$Q=\epsilon_0 \dint{} {\bf E}\cdot {\bf N}\,dS$$ 
where ${\bf E}$ is an electric field and $\epsilon_0$ (the
permittivity of free space) is a known constant; $\bf N$ is oriented
outward. 
Use Gauss's Law to find the charge contained in the cube with vertices
$(\pm 1, \pm 1, \pm 1)$ if the electric field is 
${\bf E} = \langle x,y,z\rangle$.
(<a knowl="" class="internal" value="$24\epsilon_0$">answer</a>)


</p><p>


</p><p>
</div></div></body>
</html>
